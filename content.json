[{"title":"2020-4-23-14-00","date":"2020-04-23T06:11:44.000Z","path":"2020/04/23/2020-4-23-14-00/","text":"计算机组成原理笔记(2020.4.23)有道云笔记","content":"<h1 id=\"计算机组成原理笔记-2020-4-23\"><a href=\"#计算机组成原理笔记-2020-4-23\" class=\"headerlink\" title=\"计算机组成原理笔记(2020.4.23)\"></a>计算机组成原理笔记(2020.4.23)</h1><h2 id=\"有道云笔记\"><a href=\"#有道云笔记\" class=\"headerlink\" title=\"有道云笔记\"></a><a href=\"http://note.youdao.com/noteshare?id=96c9272c729c7b0e11fd3f10d0c587da\" target=\"_blank\">有道云笔记</a></h2>","tags":[]},{"title":"2020-4-21-10-00","date":"2020-04-21T02:06:49.000Z","path":"2020/04/21/2020-4-21-10-00/","text":"uni-app生成小程序需要注意的几个坑!!! 1.生成小程序时不能用id选择器，要用class选择器。2.小程序的生命周期函数不能用在子组件里，要用在父组件里。3.生成小程序没有window对象，包括没有document…等等。","content":"<h1 id=\"uni-app生成小程序需要注意的几个坑\"><a href=\"#uni-app生成小程序需要注意的几个坑\" class=\"headerlink\" title=\"uni-app生成小程序需要注意的几个坑!!!\"></a>uni-app生成小程序需要注意的几个坑!!!</h1><a id=\"more\"></a>\n<h2 id=\"1-生成小程序时不能用id选择器，要用class选择器。\"><a href=\"#1-生成小程序时不能用id选择器，要用class选择器。\" class=\"headerlink\" title=\"1.生成小程序时不能用id选择器，要用class选择器。\"></a>1.生成小程序时不能用id选择器，要用class选择器。</h2><h2 id=\"2-小程序的生命周期函数不能用在子组件里，要用在父组件里。\"><a href=\"#2-小程序的生命周期函数不能用在子组件里，要用在父组件里。\" class=\"headerlink\" title=\"2.小程序的生命周期函数不能用在子组件里，要用在父组件里。\"></a>2.小程序的生命周期函数不能用在子组件里，要用在父组件里。</h2><h2 id=\"3-生成小程序没有window对象，包括没有document…等等。\"><a href=\"#3-生成小程序没有window对象，包括没有document…等等。\" class=\"headerlink\" title=\"3.生成小程序没有window对象，包括没有document…等等。\"></a>3.生成小程序没有window对象，包括没有document…等等。</h2>","tags":[]},{"title":"2020-4-20-11-00","date":"2020-04-20T02:57:41.000Z","path":"2020/04/20/2020-4-20-11-00/","text":"HTML+CSS基础面试题总结(一)对 HTML 语义化的理解1.去掉或者丢失样式的时候能够让页面呈现出清晰的结构 2.有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；3.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；4.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 HTML5 中新增加的很多标签（如：、、和等，就是基于语义化设计原则）(二)行内元素有哪些？块级元素有哪些？空(void)元素有哪些？1.行内元素:a,b,span,img,input,select,strong2.块级元素:div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,p3.空元素: (三)CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？1.默认值：initial（浏览器默认值）2.继承父级元素的定位机制：inherit3.默认：static4.相对定位：relative5.绝对定位：absolute（注意z-index）6.固定定位：fixed7.粘性定位：sticky该定位基于用户滚动的位置。a.initial：设置该属性为浏览器默认值b.inherit ：规定应该从父元素继承 position 属性的值。c.static ：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。d.relative ：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。e.absolute： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。f.fixed ：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。### fixed旧版本IE不支持g.sticky粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。注意: Internet Explorer, Edge 15 及更早 IE 版本不支(四)","content":"<h1 id=\"HTML-CSS基础面试题总结\"><a href=\"#HTML-CSS基础面试题总结\" class=\"headerlink\" title=\"HTML+CSS基础面试题总结\"></a>HTML+CSS基础面试题总结</h1><h2 id=\"一-对-HTML-语义化的理解\"><a href=\"#一-对-HTML-语义化的理解\" class=\"headerlink\" title=\"(一)对 HTML 语义化的理解\"></a>(一)对 HTML 语义化的理解</h2><h3 id=\"1-去掉或者丢失样式的时候能够让页面呈现出清晰的结构\"><a href=\"#1-去掉或者丢失样式的时候能够让页面呈现出清晰的结构\" class=\"headerlink\" title=\"1.去掉或者丢失样式的时候能够让页面呈现出清晰的结构\"></a>1.去掉或者丢失样式的时候能够让页面呈现出清晰的结构</h3><a id=\"more\"></a>\n<h3 id=\"2-有利于-SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；\"><a href=\"#2-有利于-SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；\" class=\"headerlink\" title=\"2.有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；\"></a>2.有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</h3><h3 id=\"3-方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\"><a href=\"#3-方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\" class=\"headerlink\" title=\"3.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\"></a>3.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</h3><h3 id=\"4-便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循-W3C-标准的团队都遵循这个标准，可以减少差异化。-HTML5-中新增加的很多标签（如：、、和等，就是基于语义化设计原则）\"><a href=\"#4-便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循-W3C-标准的团队都遵循这个标准，可以减少差异化。-HTML5-中新增加的很多标签（如：、、和等，就是基于语义化设计原则）\" class=\"headerlink\" title=\"4.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 HTML5 中新增加的很多标签（如：、、和等，就是基于语义化设计原则）\"></a>4.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 HTML5 中新增加的很多标签（如：<article>、<nav>、<header>和<footer>等，就是基于语义化设计原则）</footer></header></nav></article></h3><h2 id=\"二-行内元素有哪些？块级元素有哪些？空-void-元素有哪些？\"><a href=\"#二-行内元素有哪些？块级元素有哪些？空-void-元素有哪些？\" class=\"headerlink\" title=\"(二)行内元素有哪些？块级元素有哪些？空(void)元素有哪些？\"></a>(二)行内元素有哪些？块级元素有哪些？空(void)元素有哪些？</h2><h3 id=\"1-行内元素-a-b-span-img-input-select-strong\"><a href=\"#1-行内元素-a-b-span-img-input-select-strong\" class=\"headerlink\" title=\"1.行内元素:a,b,span,img,input,select,strong\"></a>1.行内元素:a,b,span,img,input,select,strong</h3><h3 id=\"2-块级元素-div-ul-ol-li-dl-dt-dd-h1-h2-h3-h4-p\"><a href=\"#2-块级元素-div-ul-ol-li-dl-dt-dd-h1-h2-h3-h4-p\" class=\"headerlink\" title=\"2.块级元素:div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,p\"></a>2.块级元素:div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,p</h3><h3 id=\"3-空元素\"><a href=\"#3-空元素\" class=\"headerlink\" title=\"3.空元素:               \"></a>3.空元素:<br> <hr> <img> <input> <link> <meta> <area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr></h3><h2 id=\"三-CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？\"><a href=\"#三-CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？\" class=\"headerlink\" title=\"(三)CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？\"></a>(三)CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？</h2><h3 id=\"1-默认值：initial（浏览器默认值）\"><a href=\"#1-默认值：initial（浏览器默认值）\" class=\"headerlink\" title=\"1.默认值：initial（浏览器默认值）\"></a>1.默认值：initial（浏览器默认值）</h3><h3 id=\"2-继承父级元素的定位机制：inherit\"><a href=\"#2-继承父级元素的定位机制：inherit\" class=\"headerlink\" title=\"2.继承父级元素的定位机制：inherit\"></a>2.继承父级元素的定位机制：inherit</h3><h3 id=\"3-默认：static\"><a href=\"#3-默认：static\" class=\"headerlink\" title=\"3.默认：static\"></a>3.默认：static</h3><h3 id=\"4-相对定位：relative\"><a href=\"#4-相对定位：relative\" class=\"headerlink\" title=\"4.相对定位：relative\"></a>4.相对定位：relative</h3><h3 id=\"5-绝对定位：absolute（注意z-index）\"><a href=\"#5-绝对定位：absolute（注意z-index）\" class=\"headerlink\" title=\"5.绝对定位：absolute（注意z-index）\"></a>5.绝对定位：absolute（注意z-index）</h3><h3 id=\"6-固定定位：fixed\"><a href=\"#6-固定定位：fixed\" class=\"headerlink\" title=\"6.固定定位：fixed\"></a>6.固定定位：fixed</h3><h3 id=\"7-粘性定位：sticky该定位基于用户滚动的位置。\"><a href=\"#7-粘性定位：sticky该定位基于用户滚动的位置。\" class=\"headerlink\" title=\"7.粘性定位：sticky该定位基于用户滚动的位置。\"></a>7.粘性定位：sticky该定位基于用户滚动的位置。</h3><h3 id=\"a-initial：设置该属性为浏览器默认值\"><a href=\"#a-initial：设置该属性为浏览器默认值\" class=\"headerlink\" title=\"a.initial：设置该属性为浏览器默认值\"></a>a.initial：设置该属性为浏览器默认值</h3><h3 id=\"b-inherit-：规定应该从父元素继承-position-属性的值。\"><a href=\"#b-inherit-：规定应该从父元素继承-position-属性的值。\" class=\"headerlink\" title=\"b.inherit ：规定应该从父元素继承 position 属性的值。\"></a>b.inherit ：规定应该从父元素继承 position 属性的值。</h3><h3 id=\"c-static-：默认值。没有定位，元素出现在正常的流中（忽略-top-bottom-left-right-或者-z-index-声明）。\"><a href=\"#c-static-：默认值。没有定位，元素出现在正常的流中（忽略-top-bottom-left-right-或者-z-index-声明）。\" class=\"headerlink\" title=\"c.static ：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\"></a>c.static ：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</h3><h3 id=\"d-relative-：生成相对定位的元素，相对于其正常位置进行定位。因此，”left-20”-会向元素的-LEFT-位置添加-20-像素。\"><a href=\"#d-relative-：生成相对定位的元素，相对于其正常位置进行定位。因此，”left-20”-会向元素的-LEFT-位置添加-20-像素。\" class=\"headerlink\" title=\"d.relative ：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。\"></a>d.relative ：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</h3><h3 id=\"e-absolute：-生成绝对定位的元素，相对于-static-定位以外的第一个父元素进行定位。元素的位置通过-”left”-”top”-”right”-以及-”bottom”-属性进行规定。\"><a href=\"#e-absolute：-生成绝对定位的元素，相对于-static-定位以外的第一个父元素进行定位。元素的位置通过-”left”-”top”-”right”-以及-”bottom”-属性进行规定。\" class=\"headerlink\" title=\"e.absolute： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。\"></a>e.absolute： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。</h3><h3 id=\"f-fixed-：生成绝对定位的元素，相对于浏览器窗口进行定位。\"><a href=\"#f-fixed-：生成绝对定位的元素，相对于浏览器窗口进行定位。\" class=\"headerlink\" title=\"f.fixed ：生成绝对定位的元素，相对于浏览器窗口进行定位。\"></a>f.fixed ：生成绝对定位的元素，相对于浏览器窗口进行定位。</h3><h3 id=\"元素的位置通过-”left”-”top”-”right”-以及-”bottom”-属性进行规定。-fixed旧版本IE不支持\"><a href=\"#元素的位置通过-”left”-”top”-”right”-以及-”bottom”-属性进行规定。-fixed旧版本IE不支持\" class=\"headerlink\" title=\"元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。### fixed旧版本IE不支持\"></a>元素的位置通过 ”left”, ”top”, ”right” 以及 ”bottom” 属性进行规定。### fixed旧版本IE不支持</h3><h3 id=\"g-sticky\"><a href=\"#g-sticky\" class=\"headerlink\" title=\"g.sticky\"></a>g.sticky</h3><h3 id=\"粘性定位，该定位基于用户滚动的位置。（特定阈值指的是-top-right-bottom-或-left-之一）\"><a href=\"#粘性定位，该定位基于用户滚动的位置。（特定阈值指的是-top-right-bottom-或-left-之一）\" class=\"headerlink\" title=\"粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）\"></a>粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）</h3><h3 id=\"它的行为就像-position-relative-而当页面滚动超出目标区域时，\"><a href=\"#它的行为就像-position-relative-而当页面滚动超出目标区域时，\" class=\"headerlink\" title=\"它的行为就像 position:relative; 而当页面滚动超出目标区域时，\"></a>它的行为就像 position:relative; 而当页面滚动超出目标区域时，</h3><h3 id=\"它的表现就像-position-fixed-，它会固定在目标位置。\"><a href=\"#它的表现就像-position-fixed-，它会固定在目标位置。\" class=\"headerlink\" title=\"它的表现就像 position:fixed;，它会固定在目标位置。\"></a>它的表现就像 position:fixed;，它会固定在目标位置。</h3><h3 id=\"注意-Internet-Explorer-Edge-15-及更早-IE-版本不支\"><a href=\"#注意-Internet-Explorer-Edge-15-及更早-IE-版本不支\" class=\"headerlink\" title=\"注意: Internet Explorer, Edge 15 及更早 IE 版本不支\"></a>注意: Internet Explorer, Edge 15 及更早 IE 版本不支</h3><h2 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"(四)\"></a>(四)</h2>","tags":[]},{"title":"2020-4-20-10-30","date":"2020-04-20T02:29:25.000Z","path":"2020/04/20/2020-4-20-10-30/","text":"如何运用uni-app进行程序的打包以及生成二维码下载(一)配置好manifest.json文件中所需要的选项。 (二)点击 运行 —&gt; 原生App-云打包，配置完后点击打包，首次打包，提示说appid不能为空，跳转出基础配置页面，点击云端获取，接下来再次打包就可以顺利完成了。(三)打包完成后，会出现项目地址，复制地址，打开二维码生成器把地址输入。(四)用手机扫描生成出来的二维码，这样就可以在手机中下载刚生成的程序了。","content":"<h1 id=\"如何运用uni-app进行程序的打包以及生成二维码下载\"><a href=\"#如何运用uni-app进行程序的打包以及生成二维码下载\" class=\"headerlink\" title=\"如何运用uni-app进行程序的打包以及生成二维码下载\"></a>如何运用uni-app进行程序的打包以及生成二维码下载</h1><h2 id=\"一-配置好manifest-json文件中所需要的选项。\"><a href=\"#一-配置好manifest-json文件中所需要的选项。\" class=\"headerlink\" title=\"(一)配置好manifest.json文件中所需要的选项。\"></a>(一)配置好manifest.json文件中所需要的选项。</h2><a id=\"more\"></a>\n<h2 id=\"二-点击-运行-—-gt-原生App-云打包，配置完后点击打包，首次打包，提示说appid不能为空，跳转出基础配置页面，点击云端获取，接下来再次打包就可以顺利完成了。\"><a href=\"#二-点击-运行-—-gt-原生App-云打包，配置完后点击打包，首次打包，提示说appid不能为空，跳转出基础配置页面，点击云端获取，接下来再次打包就可以顺利完成了。\" class=\"headerlink\" title=\"(二)点击 运行 —&gt; 原生App-云打包，配置完后点击打包，首次打包，提示说appid不能为空，跳转出基础配置页面，点击云端获取，接下来再次打包就可以顺利完成了。\"></a>(二)点击 运行 —&gt; 原生App-云打包，配置完后点击打包，首次打包，提示说appid不能为空，跳转出基础配置页面，点击云端获取，接下来再次打包就可以顺利完成了。</h2><h2 id=\"三-打包完成后，会出现项目地址，复制地址，打开二维码生成器把地址输入。\"><a href=\"#三-打包完成后，会出现项目地址，复制地址，打开二维码生成器把地址输入。\" class=\"headerlink\" title=\"(三)打包完成后，会出现项目地址，复制地址，打开二维码生成器把地址输入。\"></a>(三)打包完成后，会出现项目地址，复制地址，打开二维码生成器把地址输入。</h2><h2 id=\"四-用手机扫描生成出来的二维码，这样就可以在手机中下载刚生成的程序了。\"><a href=\"#四-用手机扫描生成出来的二维码，这样就可以在手机中下载刚生成的程序了。\" class=\"headerlink\" title=\"(四)用手机扫描生成出来的二维码，这样就可以在手机中下载刚生成的程序了。\"></a>(四)用手机扫描生成出来的二维码，这样就可以在手机中下载刚生成的程序了。</h2>","tags":[]},{"title":"Wed Apr 15 2020 00:00:00 GMT+0800 (GMT+08:00)","date":"2020-04-15T01:39:01.000Z","path":"2020/04/15/2020-4-15-9-38/","text":"巩固JavaScript基础打卡及总结(4.15)一.JavaScript的数据类型1.typeof 的返回值是一个字符串类型的数据，typeof检测任何数据。返回的都是一个字符串，两次和两次以上的连续typeof结果肯定都是string。2.变量是没有类型的，只有值才有，变量可以随时持有任何类型的值。在变量执行typeof操作时候，得到的结果并不是该变量的类型，而是该变量持有值的类型。 二.JavaScript中的字符串类型(一)字符串特性1.由0个或多个16位unicode字符组成。必须要有引号包裹，单引号和双引号都可以，但是单引号和双引号不能交叉使用（放在引号内的任何东西都是属于字符串，即使里面没有东西或者是空格，都属于合法的字符串 ）2.使用.length属性可以访问字符串的长度，length计算包括空格。3.无法精确返回双字节字符长度(上面已经做说明)4.转义序列表示一个字符。5.字符串一旦被创建，其值是不能改变的，若要改变必须销毁原有字符串，然后用另一个包含新值的字符串填充改变量。(二)字符串方法1.toString():把别的类型数据，转为字符串。2.String():null和undefined没有toString方法，所以转换的时候用String()函数。3.eval():计算字符串表达式的值并以数值形式返回.三.JavaScript中的数字类型(一)浮点数1.小数点后至少一位数字2.可以用科学计算法a.小数点后带有6个0的浮点数b.以e为底*10的正负N次幂3.最高精度：17位小数4.缺点:a.存在舍入误差(浮点数之间的运算也是非常不准确的，需要转成整数，然后再运算，运算后再转回对应的小数)b.无法测试特定浮点数值，不要直接对浮点数进行运算.c.在做有浮点数运算的情况下，先转成整数，然后得到结果后再转成小数.(二)NaN1.特点:任何涉及NaN的操作都将返回NaN，NaN与人和数值都不相等包括其自身。2.检测isNaN:可以转换为数值，为false。不能转换为数值，为true。(三)数值转换的三种方法1.Number() 最霸道的转换方法，只要不是纯数值类型，全部不能成功转换。2.parseInt() 是Number的升级版本；有字符串出现也可能转换为数值；从前往后开始转，只要有一位可以转为数字都可以成功转换为数字；123sad可以转为123。（备注:会忽略浮点号；遇到第一个非数值的符号后直接退出转换,其中”.“也是不合法的数值符号）3.parseFloat() 属于parseInt的升级版本；可以转换为浮点数123.12dw可以转换为123.12。-0 比如”5”-0; 这个方法也属于Number()的；但是它属于隐式调用Number方法。+“52” 这种也可以转化为数字；使用单目加法运算符,也是可以将字符串转换为数字的。(运算符那节会讲，现在仅作了解即可；)四.JavaScript中的boolean类型(一)boolean特性1.true 不一定 =1；flase 不一定 =0；2.使用 boolean() 进行转换；任何数据类型的值调用 Boolean() 函数，都会返回一个 Boolean 值；也可以用 (!/!! 来转换）a.转为 true 的:Boolean 的 true 本身任何非空字符串任何非零数值对象b.转换为 flase:false 本身空字符串null 和 undefined0 和 NaN（0 ==== -0 吗？可以输出看一下，是等于的）五.JavaScript中的object类型1.定义：一组数据或功能的集合。2.constructor：保存用于创建当前对象的函数，构造函数就是Object()3.HasOwnProperty(propertyName) 检测给定输定在当前对象实例中是否存在（而不是实例的原型中）4.isPrototypeOf(object) ：检测传入的对象是否是另一个对象的原型（而不是在实例中）。5.propertyIsEnumerable(propertyName)；检测给定属性是否能用for-in语句每句来枚举。6.toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应。7.toString() 返回对象的字符串表示。8.valueOf() 返回对象的字符串，数值或布尔值表示；通常与toString()的值相同。在ECMAScript中，Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法；方法的具体原理，后面数据类型和原型链中具体说。BOM/DOM中的对象，都是属于宿主对象，因为他们是由宿主实现提供和定义的，但是ECMAScript不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。六.JavaScript中的null和undefined类型1.undefined类型只有一个值，就是undefined；null类型也只有一个值就是null；它们的名称既是类型也是值。2.null（空值，曾经赋过值，但是目前没有值）a.逻辑上null表示一个空对象的指针。b.使用typeof检测的时候会返回object。（object原型的终点也是null）3.undefined（没有值，指从没有赋过值）a.使用var声明变量但没有初始化/赋值的。b.区分空对象指针与尚未定义的变量。c.对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined。4.在非严格模式和严格模式下，我们可以声明一个undefined的局部变量，因为undefined是一个标识符，可以当作变量来使用和赋值；但却不能声明一个null的局部变量，因为null是一个特殊关键字，并不是一个标识符；注意这是为了深入理解null和undefined的背后原理而挖出来的不同，请不要真的声明一个undefined的变量（这是一个非常不好的习惯，严格点的压缩工具，压缩时都不会给你通过的，直接给你抛Error；）七.JavaScript中null和undefined的区别和联系undefined是javascript中的一大特点，是javascript独有的数据和数据类型这个数据类型只有这一个值；就是undefined，它的类型也是undefined，既然它是javascript独有的一个数据类型，那它在javascript编程里必然有它的特点；所以再重复说下；在javascript里，null和undefined都表示不存在的数据，并且undefined也是从null中继承而来的。那null是什么？undefined又是什么？他们两个都有什么共性和区别呢？看下面描述。1.null和undefined都是表示没有的，不存在的值；他们两个在进行逻辑转换时候都是false；这两个值进行比较是true。a.null和undefined没有toString方法；所以null和undefined和任何数据比较都是false。b.因为undefined派生自null，所以undefined和null做数据类型比较的时候的true。2.null表示空引用，它是object类型，undefined表示未定义，它是undefined类型。3.null是object类型，但不是object的实例；用instanceof为false。4.如果一个变量的值是null，那么必须主动的给它赋值null。5.一个变量未定义，或者变量定义里未赋值；则是undefined。需要注意的是，一个变量如果没有定义，是不能直接在程序里使用的（就是不能直接读取，但可以赋值）；比如说，本来没有定义一个叫a的变量；但是我去aconsole.log(a);在浏览器里这个语法会报错的；但是可以用typeof去运算；但是如果a定义了，但没有赋值；可以读，它的值就是undefined；表示这个变量没有被赋值。6.对于属性来说，如果原来没有这个属性，根本就不存在这个属性，那么它的值就是undefined。对象的属性不需要定义，如果不存在也可以直接去读，不会报错，而会给一个undefined的值。7.如果这个对象以后要用；但是现在还没有值，一般情况下，会给他一个null的值。（如果在处理数据的时候，临时创建了一个变量，逻辑运算后，这个变量没有用了，也推荐把这个对象置为null,比如做定时器的时候）8.在函数(方法)里，如果必须返回值；但是值又计算不出来，那就返回一个null。（这是规范，而不是语法规定，JS里遵循这个规范）a.比如网页中没有ID是div1的元素，则下面的这句脚本返回null。b.Document.getElementById(“div1”)//返回null。c.但是没有返回值的函数，它的返回值都是undefined。八.JavaScript中的Symbol类型(一)Symbol存在的意义Symbol 是JavaScript的原始数据类型，Symbol实例是唯一且不可改变的.可以作为对象属性的标识符使用;在没有ES6的时候，属性名是很容易被覆盖的；ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。为了从根本上防止属性名的冲突，就是ES6引入Symbol的原因。在其他编程语言中 symbol也被称为原子(atoms).在JavaScript中, Symbol 是 基本数据类型 的一种，Symbol 对象是 Symbol原始值的封装 ,Symbol 类型是 ECMAScript 6 (es6) 中新添加的特性，在ECMAScript 5中没有对应的类型。(二)Symbol特性1.创建SymbolSymbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型。一是原来就有的字符串， 二是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。注意不要用new来生成new；即时在ES5中，除了使用自己定义构造函数外，也不推荐加new；因为历史遗留原因，ES6中new创建string也支持，但不推荐这么用。Symbol函数前不能使用new命令，是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。2.Symbol的参数Symbol的参数，是描述使用的；仅仅是为了控制输出时候方便识别，没有别的用了。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。注意:Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。3.Symbol值不能与其他类型的值进行运算，会报错但是可以显式转为字符串/布尔值;但是不能转为数值。4.作为属性名的Symbol如果我们不知道Symbol的实例名字是什么，我们怎么获取到Symbol值的呢, Symbol无法被for in，for of循环，以及Object.keys, Object.values等都无法遍历到Symbol的属性；Object下给我们提供了一个getOwnPropertySymbols。5.Symbol.for和 Symbol.keyForSymbol.for和Symbol的唯一区别是 Symbol.for创建的两个实例可能相等， 根据Symbol的参数生成实例，如果参数一样，那么会返回同一个实例。(三)Symbol的属性以及这些属性的用处1.Symbol.prototype: Symbol有指向的原型：2.Symbol.length: Symbol的length为1， 也就是说调用Symbol需要一个参数， 当然不给参数也没啥事。3.Symbol.Iterator：对象的Symbol.Iterator属性， 指向这个对象的默认遍历器。4.Symbol.match：ES6中字符串去匹配对象的Symbol.match方法， 匹配的结果完全可控， 以下Demo，相当于把字符串”strstring”作为obj[Symbol.match]方法的参数， 然后返回用户设定的值， chrome和FF目前还不支持。5.Symbol.replace:和上面的道理一样。6.Symbol.split:和上面的道理一样。7.Symbol.toPrimitive:对象的Symbol.toPrimitive指向一个方法，当对象转化为原始值得话，会调用这个方法，一个对象转为原始值由三种情况：string, number, default。8.Symbol.toStringTag：Symbol.toStringTag, 这个玩意儿厉害了，连对象的toString方法都给改了，而且用 Object.prototype.toString.call 这个对象输出也是一样的。九.JavaScript中的BigInt类型1.BigInt是一种内置对象，可以表示大于 253-1 的整数。而在 Javascript 中，Number 基本类型可以精确表示的最大整数是 253-1 。BigInt 可以表示任意大的整数。2.可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()。它在某些方面类似于 Number ，但是也有几个关键的不同点：不能用与 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。3.使用 typeof 测试时， BigInt 对象返回 “bigint” 。使用 Object 包装后，BigInt被认为时一个普通“object”。4.BigInt 在需要转换成 Boolean 的时表现跟 Number 类似：如通过 Boolean 函数转换；用于 Logical Operators ||, &amp;&amp;, 和 ! 的操作数；或者用于在像 if statement 这样的条件语句中。","content":"<h1 id=\"巩固JavaScript基础打卡及总结-4-15\"><a href=\"#巩固JavaScript基础打卡及总结-4-15\" class=\"headerlink\" title=\"巩固JavaScript基础打卡及总结(4.15)\"></a>巩固JavaScript基础打卡及总结(4.15)</h1><h2 id=\"一-JavaScript的数据类型\"><a href=\"#一-JavaScript的数据类型\" class=\"headerlink\" title=\"一.JavaScript的数据类型\"></a><em>一.JavaScript的数据类型</em></h2><h3 id=\"1-typeof-的返回值是一个字符串类型的数据，typeof检测任何数据。返回的都是一个字符串，两次和两次以上的连续typeof结果肯定都是string。\"><a href=\"#1-typeof-的返回值是一个字符串类型的数据，typeof检测任何数据。返回的都是一个字符串，两次和两次以上的连续typeof结果肯定都是string。\" class=\"headerlink\" title=\"1.typeof 的返回值是一个字符串类型的数据，typeof检测任何数据。返回的都是一个字符串，两次和两次以上的连续typeof结果肯定都是string。\"></a>1.typeof 的返回值是一个字符串类型的数据，typeof检测任何数据。返回的都是一个字符串，两次和两次以上的连续typeof结果肯定都是string。</h3><h3 id=\"2-变量是没有类型的，只有值才有，变量可以随时持有任何类型的值。在变量执行typeof操作时候，得到的结果并不是该变量的类型，而是该变量持有值的类型。\"><a href=\"#2-变量是没有类型的，只有值才有，变量可以随时持有任何类型的值。在变量执行typeof操作时候，得到的结果并不是该变量的类型，而是该变量持有值的类型。\" class=\"headerlink\" title=\"2.变量是没有类型的，只有值才有，变量可以随时持有任何类型的值。在变量执行typeof操作时候，得到的结果并不是该变量的类型，而是该变量持有值的类型。\"></a>2.变量是没有类型的，只有值才有，变量可以随时持有任何类型的值。在变量执行typeof操作时候，得到的结果并不是该变量的类型，而是该变量持有值的类型。</h3><a id=\"more\"></a>\n<h2 id=\"二-JavaScript中的字符串类型\"><a href=\"#二-JavaScript中的字符串类型\" class=\"headerlink\" title=\"二.JavaScript中的字符串类型\"></a><em>二.JavaScript中的字符串类型</em></h2><h3 id=\"一-字符串特性\"><a href=\"#一-字符串特性\" class=\"headerlink\" title=\"(一)字符串特性\"></a>(一)字符串特性</h3><h3 id=\"1-由0个或多个16位unicode字符组成。必须要有引号包裹，单引号和双引号都可以，但是单引号和双引号不能交叉使用（放在引号内的任何东西都是属于字符串，即使里面没有东西或者是空格，都属于合法的字符串-）\"><a href=\"#1-由0个或多个16位unicode字符组成。必须要有引号包裹，单引号和双引号都可以，但是单引号和双引号不能交叉使用（放在引号内的任何东西都是属于字符串，即使里面没有东西或者是空格，都属于合法的字符串-）\" class=\"headerlink\" title=\"1.由0个或多个16位unicode字符组成。必须要有引号包裹，单引号和双引号都可以，但是单引号和双引号不能交叉使用（放在引号内的任何东西都是属于字符串，即使里面没有东西或者是空格，都属于合法的字符串 ）\"></a>1.由0个或多个16位unicode字符组成。必须要有引号包裹，单引号和双引号都可以，但是单引号和双引号不能交叉使用（放在引号内的任何东西都是属于字符串，即使里面没有东西或者是空格，都属于合法的字符串 ）</h3><h3 id=\"2-使用-length属性可以访问字符串的长度，length计算包括空格。\"><a href=\"#2-使用-length属性可以访问字符串的长度，length计算包括空格。\" class=\"headerlink\" title=\"2.使用.length属性可以访问字符串的长度，length计算包括空格。\"></a>2.使用.length属性可以访问字符串的长度，length计算包括空格。</h3><h3 id=\"3-无法精确返回双字节字符长度-上面已经做说明\"><a href=\"#3-无法精确返回双字节字符长度-上面已经做说明\" class=\"headerlink\" title=\"3.无法精确返回双字节字符长度(上面已经做说明)\"></a>3.无法精确返回双字节字符长度(上面已经做说明)</h3><h3 id=\"4-转义序列表示一个字符。\"><a href=\"#4-转义序列表示一个字符。\" class=\"headerlink\" title=\"4.转义序列表示一个字符。\"></a>4.转义序列表示一个字符。</h3><h3 id=\"5-字符串一旦被创建，其值是不能改变的，若要改变必须销毁原有字符串，然后用另一个包含新值的字符串填充改变量。\"><a href=\"#5-字符串一旦被创建，其值是不能改变的，若要改变必须销毁原有字符串，然后用另一个包含新值的字符串填充改变量。\" class=\"headerlink\" title=\"5.字符串一旦被创建，其值是不能改变的，若要改变必须销毁原有字符串，然后用另一个包含新值的字符串填充改变量。\"></a>5.字符串一旦被创建，其值是不能改变的，若要改变必须销毁原有字符串，然后用另一个包含新值的字符串填充改变量。</h3><h3 id=\"二-字符串方法\"><a href=\"#二-字符串方法\" class=\"headerlink\" title=\"(二)字符串方法\"></a>(二)字符串方法</h3><h3 id=\"1-toString\"><a href=\"#1-toString\" class=\"headerlink\" title=\"1.toString():\"></a>1.toString():</h3><h3 id=\"把别的类型数据，转为字符串。\"><a href=\"#把别的类型数据，转为字符串。\" class=\"headerlink\" title=\"把别的类型数据，转为字符串。\"></a>把别的类型数据，转为字符串。</h3><h3 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2.String():\"></a>2.String():</h3><h3 id=\"null和undefined没有toString方法，所以转换的时候用String-函数。\"><a href=\"#null和undefined没有toString方法，所以转换的时候用String-函数。\" class=\"headerlink\" title=\"null和undefined没有toString方法，所以转换的时候用String()函数。\"></a>null和undefined没有toString方法，所以转换的时候用String()函数。</h3><h3 id=\"3-eval\"><a href=\"#3-eval\" class=\"headerlink\" title=\"3.eval():\"></a>3.eval():</h3><h3 id=\"计算字符串表达式的值并以数值形式返回\"><a href=\"#计算字符串表达式的值并以数值形式返回\" class=\"headerlink\" title=\"计算字符串表达式的值并以数值形式返回.\"></a>计算字符串表达式的值并以数值形式返回.</h3><h2 id=\"三-JavaScript中的数字类型\"><a href=\"#三-JavaScript中的数字类型\" class=\"headerlink\" title=\"三.JavaScript中的数字类型\"></a><em>三.JavaScript中的数字类型</em></h2><h3 id=\"一-浮点数\"><a href=\"#一-浮点数\" class=\"headerlink\" title=\"(一)浮点数\"></a>(一)浮点数</h3><h3 id=\"1-小数点后至少一位数字\"><a href=\"#1-小数点后至少一位数字\" class=\"headerlink\" title=\"1.小数点后至少一位数字\"></a>1.小数点后至少一位数字</h3><h3 id=\"2-可以用科学计算法\"><a href=\"#2-可以用科学计算法\" class=\"headerlink\" title=\"2.可以用科学计算法\"></a>2.可以用科学计算法</h3><h4 id=\"a-小数点后带有6个0的浮点数\"><a href=\"#a-小数点后带有6个0的浮点数\" class=\"headerlink\" title=\"a.小数点后带有6个0的浮点数\"></a>a.小数点后带有6个0的浮点数</h4><h4 id=\"b-以e为底-10的正负N次幂\"><a href=\"#b-以e为底-10的正负N次幂\" class=\"headerlink\" title=\"b.以e为底*10的正负N次幂\"></a>b.以e为底*10的正负N次幂</h4><h3 id=\"3-最高精度：17位小数\"><a href=\"#3-最高精度：17位小数\" class=\"headerlink\" title=\"3.最高精度：17位小数\"></a>3.最高精度：17位小数</h3><h3 id=\"4-缺点\"><a href=\"#4-缺点\" class=\"headerlink\" title=\"4.缺点:\"></a>4.缺点:</h3><h3 id=\"a-存在舍入误差-浮点数之间的运算也是非常不准确的，需要转成整数，然后再运算，运算后再转回对应的小数\"><a href=\"#a-存在舍入误差-浮点数之间的运算也是非常不准确的，需要转成整数，然后再运算，运算后再转回对应的小数\" class=\"headerlink\" title=\"a.存在舍入误差(浮点数之间的运算也是非常不准确的，需要转成整数，然后再运算，运算后再转回对应的小数)\"></a>a.存在舍入误差(浮点数之间的运算也是非常不准确的，需要转成整数，然后再运算，运算后再转回对应的小数)</h3><h3 id=\"b-无法测试特定浮点数值，不要直接对浮点数进行运算\"><a href=\"#b-无法测试特定浮点数值，不要直接对浮点数进行运算\" class=\"headerlink\" title=\"b.无法测试特定浮点数值，不要直接对浮点数进行运算.\"></a>b.无法测试特定浮点数值，不要直接对浮点数进行运算.</h3><h3 id=\"c-在做有浮点数运算的情况下，先转成整数，然后得到结果后再转成小数\"><a href=\"#c-在做有浮点数运算的情况下，先转成整数，然后得到结果后再转成小数\" class=\"headerlink\" title=\"c.在做有浮点数运算的情况下，先转成整数，然后得到结果后再转成小数.\"></a>c.在做有浮点数运算的情况下，先转成整数，然后得到结果后再转成小数.</h3><h3 id=\"二-NaN\"><a href=\"#二-NaN\" class=\"headerlink\" title=\"(二)NaN\"></a>(二)NaN</h3><h3 id=\"1-特点\"><a href=\"#1-特点\" class=\"headerlink\" title=\"1.特点:\"></a>1.特点:</h3><h3 id=\"任何涉及NaN的操作都将返回NaN，NaN与人和数值都不相等包括其自身。\"><a href=\"#任何涉及NaN的操作都将返回NaN，NaN与人和数值都不相等包括其自身。\" class=\"headerlink\" title=\"任何涉及NaN的操作都将返回NaN，NaN与人和数值都不相等包括其自身。\"></a>任何涉及NaN的操作都将返回NaN，NaN与人和数值都不相等包括其自身。</h3><h3 id=\"2-检测isNaN\"><a href=\"#2-检测isNaN\" class=\"headerlink\" title=\"2.检测isNaN:\"></a>2.检测isNaN:</h3><h3 id=\"可以转换为数值，为false。\"><a href=\"#可以转换为数值，为false。\" class=\"headerlink\" title=\"可以转换为数值，为false。\"></a>可以转换为数值，为false。</h3><h3 id=\"不能转换为数值，为true。\"><a href=\"#不能转换为数值，为true。\" class=\"headerlink\" title=\"不能转换为数值，为true。\"></a>不能转换为数值，为true。</h3><h3 id=\"三-数值转换的三种方法\"><a href=\"#三-数值转换的三种方法\" class=\"headerlink\" title=\"(三)数值转换的三种方法\"></a>(三)数值转换的三种方法</h3><h3 id=\"1-Number-最霸道的转换方法，只要不是纯数值类型，全部不能成功转换。\"><a href=\"#1-Number-最霸道的转换方法，只要不是纯数值类型，全部不能成功转换。\" class=\"headerlink\" title=\"1.Number() 最霸道的转换方法，只要不是纯数值类型，全部不能成功转换。\"></a>1.Number() 最霸道的转换方法，只要不是纯数值类型，全部不能成功转换。</h3><h3 id=\"2-parseInt-是Number的升级版本；有字符串出现也可能转换为数值；从前往后开始转，只要有一位可以转为数字都可以成功转换为数字；123sad可以转为123。（备注-会忽略浮点号；遇到第一个非数值的符号后直接退出转换-其中”-“也是不合法的数值符号）\"><a href=\"#2-parseInt-是Number的升级版本；有字符串出现也可能转换为数值；从前往后开始转，只要有一位可以转为数字都可以成功转换为数字；123sad可以转为123。（备注-会忽略浮点号；遇到第一个非数值的符号后直接退出转换-其中”-“也是不合法的数值符号）\" class=\"headerlink\" title=\"2.parseInt() 是Number的升级版本；有字符串出现也可能转换为数值；从前往后开始转，只要有一位可以转为数字都可以成功转换为数字；123sad可以转为123。（备注:会忽略浮点号；遇到第一个非数值的符号后直接退出转换,其中”.“也是不合法的数值符号）\"></a>2.parseInt() 是Number的升级版本；有字符串出现也可能转换为数值；从前往后开始转，只要有一位可以转为数字都可以成功转换为数字；123sad可以转为123。（备注:会忽略浮点号；遇到第一个非数值的符号后直接退出转换,其中”.“也是不合法的数值符号）</h3><h3 id=\"3-parseFloat-属于parseInt的升级版本；可以转换为浮点数123-12dw可以转换为123-12。\"><a href=\"#3-parseFloat-属于parseInt的升级版本；可以转换为浮点数123-12dw可以转换为123-12。\" class=\"headerlink\" title=\"3.parseFloat() 属于parseInt的升级版本；可以转换为浮点数123.12dw可以转换为123.12。\"></a>3.parseFloat() 属于parseInt的升级版本；可以转换为浮点数123.12dw可以转换为123.12。</h3><h4 id=\"0-比如”5”-0-这个方法也属于Number-的；但是它属于隐式调用Number方法。\"><a href=\"#0-比如”5”-0-这个方法也属于Number-的；但是它属于隐式调用Number方法。\" class=\"headerlink\" title=\"-0 比如”5”-0; 这个方法也属于Number()的；但是它属于隐式调用Number方法。\"></a>-0 比如”5”-0; 这个方法也属于Number()的；但是它属于隐式调用Number方法。</h4><h4 id=\"“52”-这种也可以转化为数字；使用单目加法运算符-也是可以将字符串转换为数字的。-运算符那节会讲，现在仅作了解即可；\"><a href=\"#“52”-这种也可以转化为数字；使用单目加法运算符-也是可以将字符串转换为数字的。-运算符那节会讲，现在仅作了解即可；\" class=\"headerlink\" title=\"+“52” 这种也可以转化为数字；使用单目加法运算符,也是可以将字符串转换为数字的。(运算符那节会讲，现在仅作了解即可；)\"></a>+“52” 这种也可以转化为数字；使用单目加法运算符,也是可以将字符串转换为数字的。(运算符那节会讲，现在仅作了解即可；)</h4><h2 id=\"四-JavaScript中的boolean类型\"><a href=\"#四-JavaScript中的boolean类型\" class=\"headerlink\" title=\"四.JavaScript中的boolean类型\"></a><em>四.JavaScript中的boolean类型</em></h2><h3 id=\"一-boolean特性\"><a href=\"#一-boolean特性\" class=\"headerlink\" title=\"(一)boolean特性\"></a>(一)boolean特性</h3><h3 id=\"1-true-不一定-1；flase-不一定-0；\"><a href=\"#1-true-不一定-1；flase-不一定-0；\" class=\"headerlink\" title=\"1.true 不一定 =1；flase 不一定 =0；\"></a>1.true 不一定 =1；flase 不一定 =0；</h3><h3 id=\"2-使用-boolean-进行转换；任何数据类型的值调用-Boolean-函数，都会返回一个-Boolean-值；也可以用-来转换）\"><a href=\"#2-使用-boolean-进行转换；任何数据类型的值调用-Boolean-函数，都会返回一个-Boolean-值；也可以用-来转换）\" class=\"headerlink\" title=\"2.使用 boolean() 进行转换；任何数据类型的值调用 Boolean() 函数，都会返回一个 Boolean 值；也可以用 (!/!! 来转换）\"></a>2.使用 boolean() 进行转换；任何数据类型的值调用 Boolean() 函数，都会返回一个 Boolean 值；也可以用 (!/!! 来转换）</h3><h3 id=\"a-转为-true-的\"><a href=\"#a-转为-true-的\" class=\"headerlink\" title=\"a.转为 true 的:\"></a>a.转为 true 的:</h3><h3 id=\"Boolean-的-true-本身\"><a href=\"#Boolean-的-true-本身\" class=\"headerlink\" title=\"Boolean 的 true 本身\"></a>Boolean 的 true 本身</h3><h3 id=\"任何非空字符串\"><a href=\"#任何非空字符串\" class=\"headerlink\" title=\"任何非空字符串\"></a>任何非空字符串</h3><h3 id=\"任何非零数值\"><a href=\"#任何非零数值\" class=\"headerlink\" title=\"任何非零数值\"></a>任何非零数值</h3><h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h3 id=\"b-转换为-flase\"><a href=\"#b-转换为-flase\" class=\"headerlink\" title=\"b.转换为 flase:\"></a>b.转换为 flase:</h3><h3 id=\"false-本身\"><a href=\"#false-本身\" class=\"headerlink\" title=\"false 本身\"></a>false 本身</h3><h3 id=\"空字符串\"><a href=\"#空字符串\" class=\"headerlink\" title=\"空字符串\"></a>空字符串</h3><h3 id=\"null-和-undefined\"><a href=\"#null-和-undefined\" class=\"headerlink\" title=\"null 和 undefined\"></a>null 和 undefined</h3><h3 id=\"0-和-NaN（0-0-吗？可以输出看一下，是等于的）\"><a href=\"#0-和-NaN（0-0-吗？可以输出看一下，是等于的）\" class=\"headerlink\" title=\"0 和 NaN（0 ==== -0 吗？可以输出看一下，是等于的）\"></a>0 和 NaN（0 ==== -0 吗？可以输出看一下，是等于的）</h3><h2 id=\"五-JavaScript中的object类型\"><a href=\"#五-JavaScript中的object类型\" class=\"headerlink\" title=\"五.JavaScript中的object类型\"></a><em>五.JavaScript中的object类型</em></h2><h3 id=\"1-定义：一组数据或功能的集合。\"><a href=\"#1-定义：一组数据或功能的集合。\" class=\"headerlink\" title=\"1.定义：一组数据或功能的集合。\"></a>1.定义：一组数据或功能的集合。</h3><h3 id=\"2-constructor：保存用于创建当前对象的函数，构造函数就是Object\"><a href=\"#2-constructor：保存用于创建当前对象的函数，构造函数就是Object\" class=\"headerlink\" title=\"2.constructor：保存用于创建当前对象的函数，构造函数就是Object()\"></a>2.constructor：保存用于创建当前对象的函数，构造函数就是Object()</h3><h3 id=\"3-HasOwnProperty-propertyName-检测给定输定在当前对象实例中是否存在（而不是实例的原型中）\"><a href=\"#3-HasOwnProperty-propertyName-检测给定输定在当前对象实例中是否存在（而不是实例的原型中）\" class=\"headerlink\" title=\"3.HasOwnProperty(propertyName) 检测给定输定在当前对象实例中是否存在（而不是实例的原型中）\"></a>3.HasOwnProperty(propertyName) 检测给定输定在当前对象实例中是否存在（而不是实例的原型中）</h3><h3 id=\"4-isPrototypeOf-object-：检测传入的对象是否是另一个对象的原型（而不是在实例中）。\"><a href=\"#4-isPrototypeOf-object-：检测传入的对象是否是另一个对象的原型（而不是在实例中）。\" class=\"headerlink\" title=\"4.isPrototypeOf(object) ：检测传入的对象是否是另一个对象的原型（而不是在实例中）。\"></a>4.isPrototypeOf(object) ：检测传入的对象是否是另一个对象的原型（而不是在实例中）。</h3><h3 id=\"5-propertyIsEnumerable-propertyName-；检测给定属性是否能用for-in语句每句来枚举。\"><a href=\"#5-propertyIsEnumerable-propertyName-；检测给定属性是否能用for-in语句每句来枚举。\" class=\"headerlink\" title=\"5.propertyIsEnumerable(propertyName)；检测给定属性是否能用for-in语句每句来枚举。\"></a>5.propertyIsEnumerable(propertyName)；检测给定属性是否能用for-in语句每句来枚举。</h3><h3 id=\"6-toLocaleString-返回对象的字符串表示，该字符串与执行环境的地区对应。\"><a href=\"#6-toLocaleString-返回对象的字符串表示，该字符串与执行环境的地区对应。\" class=\"headerlink\" title=\"6.toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应。\"></a>6.toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应。</h3><h3 id=\"7-toString-返回对象的字符串表示。\"><a href=\"#7-toString-返回对象的字符串表示。\" class=\"headerlink\" title=\"7.toString() 返回对象的字符串表示。\"></a>7.toString() 返回对象的字符串表示。</h3><h3 id=\"8-valueOf-返回对象的字符串，数值或布尔值表示；通常与toString-的值相同。\"><a href=\"#8-valueOf-返回对象的字符串，数值或布尔值表示；通常与toString-的值相同。\" class=\"headerlink\" title=\"8.valueOf() 返回对象的字符串，数值或布尔值表示；通常与toString()的值相同。\"></a>8.valueOf() 返回对象的字符串，数值或布尔值表示；通常与toString()的值相同。</h3><h3 id=\"在ECMAScript中，Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法；方法的具体原理，后面数据类型和原型链中具体说。\"><a href=\"#在ECMAScript中，Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法；方法的具体原理，后面数据类型和原型链中具体说。\" class=\"headerlink\" title=\"在ECMAScript中，Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法；方法的具体原理，后面数据类型和原型链中具体说。\"></a><em>在ECMAScript中，Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法；方法的具体原理，后面数据类型和原型链中具体说。</em></h3><h3 id=\"BOM-DOM中的对象，都是属于宿主对象，因为他们是由宿主实现提供和定义的，但是ECMAScript不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。\"><a href=\"#BOM-DOM中的对象，都是属于宿主对象，因为他们是由宿主实现提供和定义的，但是ECMAScript不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。\" class=\"headerlink\" title=\"BOM/DOM中的对象，都是属于宿主对象，因为他们是由宿主实现提供和定义的，但是ECMAScript不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。\"></a><em>BOM/DOM中的对象，都是属于宿主对象，因为他们是由宿主实现提供和定义的，但是ECMAScript不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。</em></h3><h2 id=\"六-JavaScript中的null和undefined类型\"><a href=\"#六-JavaScript中的null和undefined类型\" class=\"headerlink\" title=\"六.JavaScript中的null和undefined类型\"></a><em>六.JavaScript中的null和undefined类型</em></h2><h3 id=\"1-undefined类型只有一个值，就是undefined；null类型也只有一个值就是null；它们的名称既是类型也是值。\"><a href=\"#1-undefined类型只有一个值，就是undefined；null类型也只有一个值就是null；它们的名称既是类型也是值。\" class=\"headerlink\" title=\"1.undefined类型只有一个值，就是undefined；null类型也只有一个值就是null；它们的名称既是类型也是值。\"></a>1.undefined类型只有一个值，就是undefined；null类型也只有一个值就是null；它们的名称既是类型也是值。</h3><h3 id=\"2-null（空值，曾经赋过值，但是目前没有值）\"><a href=\"#2-null（空值，曾经赋过值，但是目前没有值）\" class=\"headerlink\" title=\"2.null（空值，曾经赋过值，但是目前没有值）\"></a>2.null（空值，曾经赋过值，但是目前没有值）</h3><h4 id=\"a-逻辑上null表示一个空对象的指针。\"><a href=\"#a-逻辑上null表示一个空对象的指针。\" class=\"headerlink\" title=\"a.逻辑上null表示一个空对象的指针。\"></a>a.逻辑上null表示一个空对象的指针。</h4><h4 id=\"b-使用typeof检测的时候会返回object。（object原型的终点也是null）\"><a href=\"#b-使用typeof检测的时候会返回object。（object原型的终点也是null）\" class=\"headerlink\" title=\"b.使用typeof检测的时候会返回object。（object原型的终点也是null）\"></a>b.使用typeof检测的时候会返回object。（object原型的终点也是null）</h4><h3 id=\"3-undefined（没有值，指从没有赋过值）\"><a href=\"#3-undefined（没有值，指从没有赋过值）\" class=\"headerlink\" title=\"3.undefined（没有值，指从没有赋过值）\"></a>3.undefined（没有值，指从没有赋过值）</h3><h4 id=\"a-使用var声明变量但没有初始化-赋值的。\"><a href=\"#a-使用var声明变量但没有初始化-赋值的。\" class=\"headerlink\" title=\"a.使用var声明变量但没有初始化/赋值的。\"></a>a.使用var声明变量但没有初始化/赋值的。</h4><h4 id=\"b-区分空对象指针与尚未定义的变量。\"><a href=\"#b-区分空对象指针与尚未定义的变量。\" class=\"headerlink\" title=\"b.区分空对象指针与尚未定义的变量。\"></a>b.区分空对象指针与尚未定义的变量。</h4><h4 id=\"c-对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined。\"><a href=\"#c-对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined。\" class=\"headerlink\" title=\"c.对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined。\"></a>c.对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined。</h4><h3 id=\"4-在非严格模式和严格模式下，我们可以声明一个undefined的局部变量，因为undefined是一个标识符，可以当作变量来使用和赋值；但却不能声明一个null的局部变量，因为null是一个特殊关键字，并不是一个标识符；注意这是为了深入理解null和undefined的背后原理而挖出来的不同，请不要真的声明一个undefined的变量（这是一个非常不好的习惯，严格点的压缩工具，压缩时都不会给你通过的，直接给你抛Error；）\"><a href=\"#4-在非严格模式和严格模式下，我们可以声明一个undefined的局部变量，因为undefined是一个标识符，可以当作变量来使用和赋值；但却不能声明一个null的局部变量，因为null是一个特殊关键字，并不是一个标识符；注意这是为了深入理解null和undefined的背后原理而挖出来的不同，请不要真的声明一个undefined的变量（这是一个非常不好的习惯，严格点的压缩工具，压缩时都不会给你通过的，直接给你抛Error；）\" class=\"headerlink\" title=\"4.在非严格模式和严格模式下，我们可以声明一个undefined的局部变量，因为undefined是一个标识符，可以当作变量来使用和赋值；但却不能声明一个null的局部变量，因为null是一个特殊关键字，并不是一个标识符；注意这是为了深入理解null和undefined的背后原理而挖出来的不同，请不要真的声明一个undefined的变量（这是一个非常不好的习惯，严格点的压缩工具，压缩时都不会给你通过的，直接给你抛Error；）\"></a>4.在非严格模式和严格模式下，我们可以声明一个undefined的局部变量，因为undefined是一个标识符，可以当作变量来使用和赋值；但却不能声明一个null的局部变量，因为null是一个特殊关键字，并不是一个标识符；注意这是为了深入理解null和undefined的背后原理而挖出来的不同，请不要真的声明一个undefined的变量（这是一个非常不好的习惯，严格点的压缩工具，压缩时都不会给你通过的，直接给你抛Error；）</h3><h2 id=\"七-JavaScript中null和undefined的区别和联系\"><a href=\"#七-JavaScript中null和undefined的区别和联系\" class=\"headerlink\" title=\"七.JavaScript中null和undefined的区别和联系\"></a><em>七.JavaScript中null和undefined的区别和联系</em></h2><h3 id=\"undefined是javascript中的一大特点，是javascript独有的数据和数据类型这个数据类型只有这一个值；就是undefined，它的类型也是undefined，既然它是javascript独有的一个数据类型，那它在javascript编程里必然有它的特点；所以再重复说下；在javascript里，null和undefined都表示不存在的数据，并且undefined也是从null中继承而来的。\"><a href=\"#undefined是javascript中的一大特点，是javascript独有的数据和数据类型这个数据类型只有这一个值；就是undefined，它的类型也是undefined，既然它是javascript独有的一个数据类型，那它在javascript编程里必然有它的特点；所以再重复说下；在javascript里，null和undefined都表示不存在的数据，并且undefined也是从null中继承而来的。\" class=\"headerlink\" title=\"undefined是javascript中的一大特点，是javascript独有的数据和数据类型这个数据类型只有这一个值；就是undefined，它的类型也是undefined，既然它是javascript独有的一个数据类型，那它在javascript编程里必然有它的特点；所以再重复说下；在javascript里，null和undefined都表示不存在的数据，并且undefined也是从null中继承而来的。\"></a>undefined是javascript中的一大特点，是javascript独有的数据和数据类型这个数据类型只有这一个值；就是undefined，它的类型也是undefined，既然它是javascript独有的一个数据类型，那它在javascript编程里必然有它的特点；所以再重复说下；在javascript里，null和undefined都表示不存在的数据，并且undefined也是从null中继承而来的。</h3><h3 id=\"那null是什么？undefined又是什么？他们两个都有什么共性和区别呢？看下面描述。\"><a href=\"#那null是什么？undefined又是什么？他们两个都有什么共性和区别呢？看下面描述。\" class=\"headerlink\" title=\"那null是什么？undefined又是什么？他们两个都有什么共性和区别呢？看下面描述。\"></a>那null是什么？undefined又是什么？他们两个都有什么共性和区别呢？看下面描述。</h3><h3 id=\"1-null和undefined都是表示没有的，不存在的值；他们两个在进行逻辑转换时候都是false；这两个值进行比较是true。\"><a href=\"#1-null和undefined都是表示没有的，不存在的值；他们两个在进行逻辑转换时候都是false；这两个值进行比较是true。\" class=\"headerlink\" title=\"1.null和undefined都是表示没有的，不存在的值；他们两个在进行逻辑转换时候都是false；这两个值进行比较是true。\"></a>1.null和undefined都是表示没有的，不存在的值；他们两个在进行逻辑转换时候都是false；这两个值进行比较是true。</h3><h3 id=\"a-null和undefined没有toString方法；所以null和undefined和任何数据比较都是false。\"><a href=\"#a-null和undefined没有toString方法；所以null和undefined和任何数据比较都是false。\" class=\"headerlink\" title=\"a.null和undefined没有toString方法；所以null和undefined和任何数据比较都是false。\"></a>a.null和undefined没有toString方法；所以null和undefined和任何数据比较都是false。</h3><h3 id=\"b-因为undefined派生自null，所以undefined和null做数据类型比较的时候的true。\"><a href=\"#b-因为undefined派生自null，所以undefined和null做数据类型比较的时候的true。\" class=\"headerlink\" title=\"b.因为undefined派生自null，所以undefined和null做数据类型比较的时候的true。\"></a>b.因为undefined派生自null，所以undefined和null做数据类型比较的时候的true。</h3><h3 id=\"2-null表示空引用，它是object类型，undefined表示未定义，它是undefined类型。\"><a href=\"#2-null表示空引用，它是object类型，undefined表示未定义，它是undefined类型。\" class=\"headerlink\" title=\"2.null表示空引用，它是object类型，undefined表示未定义，它是undefined类型。\"></a>2.null表示空引用，它是object类型，undefined表示未定义，它是undefined类型。</h3><h3 id=\"3-null是object类型，但不是object的实例；用instanceof为false。\"><a href=\"#3-null是object类型，但不是object的实例；用instanceof为false。\" class=\"headerlink\" title=\"3.null是object类型，但不是object的实例；用instanceof为false。\"></a>3.null是object类型，但不是object的实例；用instanceof为false。</h3><h3 id=\"4-如果一个变量的值是null，那么必须主动的给它赋值null。\"><a href=\"#4-如果一个变量的值是null，那么必须主动的给它赋值null。\" class=\"headerlink\" title=\"4.如果一个变量的值是null，那么必须主动的给它赋值null。\"></a>4.如果一个变量的值是null，那么必须主动的给它赋值null。</h3><h3 id=\"5-一个变量未定义，或者变量定义里未赋值；则是undefined。\"><a href=\"#5-一个变量未定义，或者变量定义里未赋值；则是undefined。\" class=\"headerlink\" title=\"5.一个变量未定义，或者变量定义里未赋值；则是undefined。\"></a>5.一个变量未定义，或者变量定义里未赋值；则是undefined。</h3><h4 id=\"需要注意的是，一个变量如果没有定义，是不能直接在程序里使用的（就是不能直接读取，但可以赋值）；比如说，本来没有定义一个叫a的变量；但是我去aconsole-log-a-在浏览器里这个语法会报错的；但是可以用typeof去运算；但是如果a定义了，但没有赋值；可以读，它的值就是undefined；表示这个变量没有被赋值。\"><a href=\"#需要注意的是，一个变量如果没有定义，是不能直接在程序里使用的（就是不能直接读取，但可以赋值）；比如说，本来没有定义一个叫a的变量；但是我去aconsole-log-a-在浏览器里这个语法会报错的；但是可以用typeof去运算；但是如果a定义了，但没有赋值；可以读，它的值就是undefined；表示这个变量没有被赋值。\" class=\"headerlink\" title=\"需要注意的是，一个变量如果没有定义，是不能直接在程序里使用的（就是不能直接读取，但可以赋值）；比如说，本来没有定义一个叫a的变量；但是我去aconsole.log(a);在浏览器里这个语法会报错的；但是可以用typeof去运算；但是如果a定义了，但没有赋值；可以读，它的值就是undefined；表示这个变量没有被赋值。\"></a>需要注意的是，一个变量如果没有定义，是不能直接在程序里使用的（就是不能直接读取，但可以赋值）；比如说，本来没有定义一个叫a的变量；但是我去aconsole.log(a);在浏览器里这个语法会报错的；但是可以用typeof去运算；但是如果a定义了，但没有赋值；可以读，它的值就是undefined；表示这个变量没有被赋值。</h4><h3 id=\"6-对于属性来说，如果原来没有这个属性，根本就不存在这个属性，那么它的值就是undefined。\"><a href=\"#6-对于属性来说，如果原来没有这个属性，根本就不存在这个属性，那么它的值就是undefined。\" class=\"headerlink\" title=\"6.对于属性来说，如果原来没有这个属性，根本就不存在这个属性，那么它的值就是undefined。\"></a>6.对于属性来说，如果原来没有这个属性，根本就不存在这个属性，那么它的值就是undefined。</h3><h4 id=\"对象的属性不需要定义，如果不存在也可以直接去读，不会报错，而会给一个undefined的值。\"><a href=\"#对象的属性不需要定义，如果不存在也可以直接去读，不会报错，而会给一个undefined的值。\" class=\"headerlink\" title=\"对象的属性不需要定义，如果不存在也可以直接去读，不会报错，而会给一个undefined的值。\"></a>对象的属性不需要定义，如果不存在也可以直接去读，不会报错，而会给一个undefined的值。</h4><h3 id=\"7-如果这个对象以后要用；但是现在还没有值，一般情况下，会给他一个null的值。（如果在处理数据的时候，临时创建了一个变量，逻辑运算后，这个变量没有用了，也推荐把这个对象置为null-比如做定时器的时候）\"><a href=\"#7-如果这个对象以后要用；但是现在还没有值，一般情况下，会给他一个null的值。（如果在处理数据的时候，临时创建了一个变量，逻辑运算后，这个变量没有用了，也推荐把这个对象置为null-比如做定时器的时候）\" class=\"headerlink\" title=\"7.如果这个对象以后要用；但是现在还没有值，一般情况下，会给他一个null的值。（如果在处理数据的时候，临时创建了一个变量，逻辑运算后，这个变量没有用了，也推荐把这个对象置为null,比如做定时器的时候）\"></a>7.如果这个对象以后要用；但是现在还没有值，一般情况下，会给他一个null的值。（如果在处理数据的时候，临时创建了一个变量，逻辑运算后，这个变量没有用了，也推荐把这个对象置为null,比如做定时器的时候）</h3><h3 id=\"8-在函数-方法-里，如果必须返回值；但是值又计算不出来，那就返回一个null。（这是规范，而不是语法规定，JS里遵循这个规范）\"><a href=\"#8-在函数-方法-里，如果必须返回值；但是值又计算不出来，那就返回一个null。（这是规范，而不是语法规定，JS里遵循这个规范）\" class=\"headerlink\" title=\"8.在函数(方法)里，如果必须返回值；但是值又计算不出来，那就返回一个null。（这是规范，而不是语法规定，JS里遵循这个规范）\"></a>8.在函数(方法)里，如果必须返回值；但是值又计算不出来，那就返回一个null。（这是规范，而不是语法规定，JS里遵循这个规范）</h3><h4 id=\"a-比如网页中没有ID是div1的元素，则下面的这句脚本返回null。\"><a href=\"#a-比如网页中没有ID是div1的元素，则下面的这句脚本返回null。\" class=\"headerlink\" title=\"a.比如网页中没有ID是div1的元素，则下面的这句脚本返回null。\"></a>a.比如网页中没有ID是div1的元素，则下面的这句脚本返回null。</h4><h4 id=\"b-Document-getElementById-“div1”-返回null。\"><a href=\"#b-Document-getElementById-“div1”-返回null。\" class=\"headerlink\" title=\"b.Document.getElementById(“div1”)//返回null。\"></a>b.Document.getElementById(“div1”)//返回null。</h4><h4 id=\"c-但是没有返回值的函数，它的返回值都是undefined。\"><a href=\"#c-但是没有返回值的函数，它的返回值都是undefined。\" class=\"headerlink\" title=\"c.但是没有返回值的函数，它的返回值都是undefined。\"></a>c.但是没有返回值的函数，它的返回值都是undefined。</h4><h2 id=\"八-JavaScript中的Symbol类型\"><a href=\"#八-JavaScript中的Symbol类型\" class=\"headerlink\" title=\"八.JavaScript中的Symbol类型\"></a><em>八.JavaScript中的Symbol类型</em></h2><h3 id=\"一-Symbol存在的意义\"><a href=\"#一-Symbol存在的意义\" class=\"headerlink\" title=\"(一)Symbol存在的意义\"></a>(一)Symbol存在的意义</h3><h3 id=\"Symbol-是JavaScript的原始数据类型，Symbol实例是唯一且不可改变的-可以作为对象属性的标识符使用-在没有ES6的时候，属性名是很容易被覆盖的；ES5-的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin-模式），新方法的名字就有可能与现有方法产生冲突。\"><a href=\"#Symbol-是JavaScript的原始数据类型，Symbol实例是唯一且不可改变的-可以作为对象属性的标识符使用-在没有ES6的时候，属性名是很容易被覆盖的；ES5-的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin-模式），新方法的名字就有可能与现有方法产生冲突。\" class=\"headerlink\" title=\"Symbol 是JavaScript的原始数据类型，Symbol实例是唯一且不可改变的.可以作为对象属性的标识符使用;在没有ES6的时候，属性名是很容易被覆盖的；ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。\"></a>Symbol 是JavaScript的原始数据类型，Symbol实例是唯一且不可改变的.可以作为对象属性的标识符使用;在没有ES6的时候，属性名是很容易被覆盖的；ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。</h3><h3 id=\"如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是-ES6-引入Symbol的原因。为了从根本上防止属性名的冲突，就是ES6引入Symbol的原因。在其他编程语言中-symbol也被称为原子-atoms\"><a href=\"#如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是-ES6-引入Symbol的原因。为了从根本上防止属性名的冲突，就是ES6引入Symbol的原因。在其他编程语言中-symbol也被称为原子-atoms\" class=\"headerlink\" title=\"如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。为了从根本上防止属性名的冲突，就是ES6引入Symbol的原因。在其他编程语言中 symbol也被称为原子(atoms).\"></a>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。为了从根本上防止属性名的冲突，就是ES6引入Symbol的原因。在其他编程语言中 symbol也被称为原子(atoms).</h3><h3 id=\"在JavaScript中-Symbol-是-基本数据类型-的一种，Symbol-对象是-Symbol原始值的封装-Symbol-类型是-ECMAScript-6-es6-中新添加的特性，在ECMAScript-5中没有对应的类型。\"><a href=\"#在JavaScript中-Symbol-是-基本数据类型-的一种，Symbol-对象是-Symbol原始值的封装-Symbol-类型是-ECMAScript-6-es6-中新添加的特性，在ECMAScript-5中没有对应的类型。\" class=\"headerlink\" title=\"在JavaScript中, Symbol 是 基本数据类型 的一种，Symbol 对象是 Symbol原始值的封装 ,Symbol 类型是 ECMAScript 6 (es6) 中新添加的特性，在ECMAScript 5中没有对应的类型。\"></a>在JavaScript中, Symbol 是 基本数据类型 的一种，Symbol 对象是 Symbol原始值的封装 ,Symbol 类型是 ECMAScript 6 (es6) 中新添加的特性，在ECMAScript 5中没有对应的类型。</h3><h3 id=\"二-Symbol特性\"><a href=\"#二-Symbol特性\" class=\"headerlink\" title=\"(二)Symbol特性\"></a>(二)Symbol特性</h3><h3 id=\"1-创建Symbol\"><a href=\"#1-创建Symbol\" class=\"headerlink\" title=\"1.创建Symbol\"></a>1.创建Symbol</h3><h4 id=\"Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型。\"><a href=\"#Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型。\" class=\"headerlink\" title=\"Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型。\"></a>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型。</h4><h4 id=\"一是原来就有的字符串，-二是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\"><a href=\"#一是原来就有的字符串，-二是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\" class=\"headerlink\" title=\"一是原来就有的字符串， 二是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\"></a>一是原来就有的字符串， 二是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</h4><h4 id=\"注意不要用new来生成new；即时在ES5中，除了使用自己定义构造函数外，也不推荐加new；因为历史遗留原因，ES6中new创建string也支持，但不推荐这么用。\"><a href=\"#注意不要用new来生成new；即时在ES5中，除了使用自己定义构造函数外，也不推荐加new；因为历史遗留原因，ES6中new创建string也支持，但不推荐这么用。\" class=\"headerlink\" title=\"注意不要用new来生成new；即时在ES5中，除了使用自己定义构造函数外，也不推荐加new；因为历史遗留原因，ES6中new创建string也支持，但不推荐这么用。\"></a>注意不要用new来生成new；即时在ES5中，除了使用自己定义构造函数外，也不推荐加new；因为历史遗留原因，ES6中new创建string也支持，但不推荐这么用。</h4><h4 id=\"Symbol函数前不能使用new命令，是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\"><a href=\"#Symbol函数前不能使用new命令，是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\" class=\"headerlink\" title=\"Symbol函数前不能使用new命令，是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\"></a>Symbol函数前不能使用new命令，是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</h4><h3 id=\"2-Symbol的参数\"><a href=\"#2-Symbol的参数\" class=\"headerlink\" title=\"2.Symbol的参数\"></a>2.Symbol的参数</h3><h4 id=\"Symbol的参数，是描述使用的；仅仅是为了控制输出时候方便识别，没有别的用了。\"><a href=\"#Symbol的参数，是描述使用的；仅仅是为了控制输出时候方便识别，没有别的用了。\" class=\"headerlink\" title=\"Symbol的参数，是描述使用的；仅仅是为了控制输出时候方便识别，没有别的用了。\"></a>Symbol的参数，是描述使用的；仅仅是为了控制输出时候方便识别，没有别的用了。</h4><h4 id=\"如果不加参数，它们在控制台的输出都是Symbol-，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\"><a href=\"#如果不加参数，它们在控制台的输出都是Symbol-，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\" class=\"headerlink\" title=\"如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\"></a>如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</h4><h4 id=\"注意-Symbol函数的参数只是表示对当前-Symbol-值的描述，因此相同参数的Symbol函数的返回值是不相等的。\"><a href=\"#注意-Symbol函数的参数只是表示对当前-Symbol-值的描述，因此相同参数的Symbol函数的返回值是不相等的。\" class=\"headerlink\" title=\"注意:Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\"></a><em>注意:</em>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</h4><h3 id=\"3-Symbol值不能与其他类型的值进行运算，会报错\"><a href=\"#3-Symbol值不能与其他类型的值进行运算，会报错\" class=\"headerlink\" title=\"3.Symbol值不能与其他类型的值进行运算，会报错\"></a>3.Symbol值不能与其他类型的值进行运算，会报错</h3><h4 id=\"但是可以显式转为字符串-布尔值-但是不能转为数值。\"><a href=\"#但是可以显式转为字符串-布尔值-但是不能转为数值。\" class=\"headerlink\" title=\"但是可以显式转为字符串/布尔值;但是不能转为数值。\"></a>但是可以显式转为字符串/布尔值;但是不能转为数值。</h4><h3 id=\"4-作为属性名的Symbol\"><a href=\"#4-作为属性名的Symbol\" class=\"headerlink\" title=\"4.作为属性名的Symbol\"></a>4.作为属性名的Symbol</h3><h4 id=\"如果我们不知道Symbol的实例名字是什么，我们怎么获取到Symbol值的呢-Symbol无法被for-in，for-of循环，以及Object-keys-Object-values等都无法遍历到Symbol的属性；Object下给我们提供了一个getOwnPropertySymbols。\"><a href=\"#如果我们不知道Symbol的实例名字是什么，我们怎么获取到Symbol值的呢-Symbol无法被for-in，for-of循环，以及Object-keys-Object-values等都无法遍历到Symbol的属性；Object下给我们提供了一个getOwnPropertySymbols。\" class=\"headerlink\" title=\"如果我们不知道Symbol的实例名字是什么，我们怎么获取到Symbol值的呢, Symbol无法被for in，for of循环，以及Object.keys, Object.values等都无法遍历到Symbol的属性；Object下给我们提供了一个getOwnPropertySymbols。\"></a>如果我们不知道Symbol的实例名字是什么，我们怎么获取到Symbol值的呢, Symbol无法被for in，for of循环，以及Object.keys, Object.values等都无法遍历到Symbol的属性；Object下给我们提供了一个getOwnPropertySymbols。</h4><h3 id=\"5-Symbol-for和-Symbol-keyFor\"><a href=\"#5-Symbol-for和-Symbol-keyFor\" class=\"headerlink\" title=\"5.Symbol.for和 Symbol.keyFor\"></a>5.Symbol.for和 Symbol.keyFor</h3><h4 id=\"Symbol-for和Symbol的唯一区别是-Symbol-for创建的两个实例可能相等，-根据Symbol的参数生成实例，如果参数一样，那么会返回同一个实例。\"><a href=\"#Symbol-for和Symbol的唯一区别是-Symbol-for创建的两个实例可能相等，-根据Symbol的参数生成实例，如果参数一样，那么会返回同一个实例。\" class=\"headerlink\" title=\"Symbol.for和Symbol的唯一区别是 Symbol.for创建的两个实例可能相等， 根据Symbol的参数生成实例，如果参数一样，那么会返回同一个实例。\"></a>Symbol.for和Symbol的唯一区别是 Symbol.for创建的两个实例可能相等， 根据Symbol的参数生成实例，如果参数一样，那么会返回同一个实例。</h4><h3 id=\"三-Symbol的属性以及这些属性的用处\"><a href=\"#三-Symbol的属性以及这些属性的用处\" class=\"headerlink\" title=\"(三)Symbol的属性以及这些属性的用处\"></a>(三)Symbol的属性以及这些属性的用处</h3><h3 id=\"1-Symbol-prototype-Symbol有指向的原型：\"><a href=\"#1-Symbol-prototype-Symbol有指向的原型：\" class=\"headerlink\" title=\"1.Symbol.prototype: Symbol有指向的原型：\"></a>1.Symbol.prototype: Symbol有指向的原型：</h3><h3 id=\"2-Symbol-length-Symbol的length为1，-也就是说调用Symbol需要一个参数，-当然不给参数也没啥事。\"><a href=\"#2-Symbol-length-Symbol的length为1，-也就是说调用Symbol需要一个参数，-当然不给参数也没啥事。\" class=\"headerlink\" title=\"2.Symbol.length: Symbol的length为1， 也就是说调用Symbol需要一个参数， 当然不给参数也没啥事。\"></a>2.Symbol.length: Symbol的length为1， 也就是说调用Symbol需要一个参数， 当然不给参数也没啥事。</h3><h3 id=\"3-Symbol-Iterator：对象的Symbol-Iterator属性，-指向这个对象的默认遍历器。\"><a href=\"#3-Symbol-Iterator：对象的Symbol-Iterator属性，-指向这个对象的默认遍历器。\" class=\"headerlink\" title=\"3.Symbol.Iterator：对象的Symbol.Iterator属性， 指向这个对象的默认遍历器。\"></a>3.Symbol.Iterator：对象的Symbol.Iterator属性， 指向这个对象的默认遍历器。</h3><h3 id=\"4-Symbol-match：ES6中字符串去匹配对象的Symbol-match方法，-匹配的结果完全可控，-以下Demo，相当于把字符串”strstring”作为obj-Symbol-match-方法的参数，-然后返回用户设定的值，-chrome和FF目前还不支持。\"><a href=\"#4-Symbol-match：ES6中字符串去匹配对象的Symbol-match方法，-匹配的结果完全可控，-以下Demo，相当于把字符串”strstring”作为obj-Symbol-match-方法的参数，-然后返回用户设定的值，-chrome和FF目前还不支持。\" class=\"headerlink\" title=\"4.Symbol.match：ES6中字符串去匹配对象的Symbol.match方法， 匹配的结果完全可控， 以下Demo，相当于把字符串”strstring”作为obj[Symbol.match]方法的参数， 然后返回用户设定的值， chrome和FF目前还不支持。\"></a>4.Symbol.match：ES6中字符串去匹配对象的Symbol.match方法， 匹配的结果完全可控， 以下Demo，相当于把字符串”strstring”作为obj[Symbol.match]方法的参数， 然后返回用户设定的值， chrome和FF目前还不支持。</h3><h3 id=\"5-Symbol-replace-和上面的道理一样。\"><a href=\"#5-Symbol-replace-和上面的道理一样。\" class=\"headerlink\" title=\"5.Symbol.replace:和上面的道理一样。\"></a>5.Symbol.replace:和上面的道理一样。</h3><h3 id=\"6-Symbol-split-和上面的道理一样。\"><a href=\"#6-Symbol-split-和上面的道理一样。\" class=\"headerlink\" title=\"6.Symbol.split:和上面的道理一样。\"></a>6.Symbol.split:和上面的道理一样。</h3><h3 id=\"7-Symbol-toPrimitive-对象的Symbol-toPrimitive指向一个方法，当对象转化为原始值得话，会调用这个方法，一个对象转为原始值由三种情况：string-number-default。\"><a href=\"#7-Symbol-toPrimitive-对象的Symbol-toPrimitive指向一个方法，当对象转化为原始值得话，会调用这个方法，一个对象转为原始值由三种情况：string-number-default。\" class=\"headerlink\" title=\"7.Symbol.toPrimitive:对象的Symbol.toPrimitive指向一个方法，当对象转化为原始值得话，会调用这个方法，一个对象转为原始值由三种情况：string, number, default。\"></a>7.Symbol.toPrimitive:对象的Symbol.toPrimitive指向一个方法，当对象转化为原始值得话，会调用这个方法，一个对象转为原始值由三种情况：string, number, default。</h3><h3 id=\"8-Symbol-toStringTag：Symbol-toStringTag-这个玩意儿厉害了，连对象的toString方法都给改了，而且用-Object-prototype-toString-call-这个对象输出也是一样的。\"><a href=\"#8-Symbol-toStringTag：Symbol-toStringTag-这个玩意儿厉害了，连对象的toString方法都给改了，而且用-Object-prototype-toString-call-这个对象输出也是一样的。\" class=\"headerlink\" title=\"8.Symbol.toStringTag：Symbol.toStringTag, 这个玩意儿厉害了，连对象的toString方法都给改了，而且用 Object.prototype.toString.call 这个对象输出也是一样的。\"></a>8.Symbol.toStringTag：Symbol.toStringTag, 这个玩意儿厉害了，连对象的toString方法都给改了，而且用 Object.prototype.toString.call 这个对象输出也是一样的。</h3><h2 id=\"九-JavaScript中的BigInt类型\"><a href=\"#九-JavaScript中的BigInt类型\" class=\"headerlink\" title=\"九.JavaScript中的BigInt类型\"></a><em>九.JavaScript中的BigInt类型</em></h2><h3 id=\"1-BigInt是一种内置对象，可以表示大于-253-1-的整数。而在-Javascript-中，Number-基本类型可以精确表示的最大整数是-253-1-。BigInt-可以表示任意大的整数。\"><a href=\"#1-BigInt是一种内置对象，可以表示大于-253-1-的整数。而在-Javascript-中，Number-基本类型可以精确表示的最大整数是-253-1-。BigInt-可以表示任意大的整数。\" class=\"headerlink\" title=\"1.BigInt是一种内置对象，可以表示大于 253-1 的整数。而在 Javascript 中，Number 基本类型可以精确表示的最大整数是 253-1 。BigInt 可以表示任意大的整数。\"></a>1.BigInt是一种内置对象，可以表示大于 253-1 的整数。而在 Javascript 中，Number 基本类型可以精确表示的最大整数是 253-1 。BigInt 可以表示任意大的整数。</h3><h3 id=\"2-可以用在一个整数字面量后面加-n-的方式定义一个-BigInt-，如：10n，或者调用函数-BigInt-。\"><a href=\"#2-可以用在一个整数字面量后面加-n-的方式定义一个-BigInt-，如：10n，或者调用函数-BigInt-。\" class=\"headerlink\" title=\"2.可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()。\"></a>2.可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()。</h3><h3 id=\"它在某些方面类似于-Number-，但是也有几个关键的不同点：不能用与-Math-对象中的方法；不能和任何-Number-实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为-BigInt-变量在转换成-Number-变量时可能会丢失精度。\"><a href=\"#它在某些方面类似于-Number-，但是也有几个关键的不同点：不能用与-Math-对象中的方法；不能和任何-Number-实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为-BigInt-变量在转换成-Number-变量时可能会丢失精度。\" class=\"headerlink\" title=\"它在某些方面类似于 Number ，但是也有几个关键的不同点：不能用与 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。\"></a>它在某些方面类似于 Number ，但是也有几个关键的不同点：不能用与 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。</h3><h3 id=\"3-使用-typeof-测试时，-BigInt-对象返回-“bigint”-。\"><a href=\"#3-使用-typeof-测试时，-BigInt-对象返回-“bigint”-。\" class=\"headerlink\" title=\"3.使用 typeof 测试时， BigInt 对象返回 “bigint” 。\"></a>3.使用 typeof 测试时， BigInt 对象返回 “bigint” 。</h3><h3 id=\"使用-Object-包装后，BigInt被认为时一个普通“object”。\"><a href=\"#使用-Object-包装后，BigInt被认为时一个普通“object”。\" class=\"headerlink\" title=\"使用 Object 包装后，BigInt被认为时一个普通“object”。\"></a>使用 Object 包装后，BigInt被认为时一个普通“object”。</h3><h3 id=\"4-BigInt-在需要转换成-Boolean-的时表现跟-Number-类似：如通过-Boolean-函数转换；用于-Logical-Operators-amp-amp-和-的操作数；或者用于在像-if-statement-这样的条件语句中。\"><a href=\"#4-BigInt-在需要转换成-Boolean-的时表现跟-Number-类似：如通过-Boolean-函数转换；用于-Logical-Operators-amp-amp-和-的操作数；或者用于在像-if-statement-这样的条件语句中。\" class=\"headerlink\" title=\"4.BigInt 在需要转换成 Boolean 的时表现跟 Number 类似：如通过 Boolean 函数转换；用于 Logical Operators ||, &amp;&amp;, 和 ! 的操作数；或者用于在像 if statement 这样的条件语句中。\"></a>4.BigInt 在需要转换成 Boolean 的时表现跟 Number 类似：如通过 Boolean 函数转换；用于 Logical Operators ||, &amp;&amp;, 和 ! 的操作数；或者用于在像 if statement 这样的条件语句中。</h3>","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"自我总结","slug":"自我总结","permalink":"http://yoursite.com/tags/自我总结/"},{"name":"打卡","slug":"打卡","permalink":"http://yoursite.com/tags/打卡/"}]},{"title":"Tue Apr 14 2020 19:37:45 GMT+0800 (GMT+08:00)","date":"2020-04-14T11:37:45.000Z","path":"2020/04/14/2020-4-14-19-37/","text":"Vue中常见的性能优化一.编码优化1.不要将所有的数据都放在data中，data中的数据都会增加gettter和setter，会收集对应watcher。 2.vue在v-for时给每个元素绑定事件，需要事件代理。3.SPA页面采用keep-alive缓存组件。4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )5.v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show。6.key保证唯一性 ( 默认vue会采用就地复用策略 )7.Object.freeze 冻结数据。8.合理使用路由懒加载、异步组件。9.尽量采用runtime运行时版本.10.数据持久化的问题（防抖、节流）二.ue加载性能优化1.第三方模块按需导入 (babel-plugin-component)2.滚动到可视区域动态加载 ( https://tangbc.github.io/vue-virtual-scroll-list )3.图片懒加载 (https://github.com/hilongjw/vue-lazyload.git)三.用户体验1.app-skeleton骨架屏2.app-shellapp壳3.pwa四.SEO优化1.预渲染插件 prerender-spa-plugin2.服务端渲染ssr五.打包优化1.使用cdn的方式加载第三方模块2.多线程打包 happypack3.splitChunks 抽离公共文件4.sourceMap生成六.缓存，压缩1.客户端缓存、服务端缓存2.服务端gzip压缩","content":"<h1 id=\"Vue中常见的性能优化\"><a href=\"#Vue中常见的性能优化\" class=\"headerlink\" title=\"Vue中常见的性能优化\"></a>Vue中常见的性能优化</h1><h2 id=\"一-编码优化\"><a href=\"#一-编码优化\" class=\"headerlink\" title=\"一.编码优化\"></a>一.编码优化</h2><h3 id=\"1-不要将所有的数据都放在data中，data中的数据都会增加gettter和setter，会收集对应watcher。\"><a href=\"#1-不要将所有的数据都放在data中，data中的数据都会增加gettter和setter，会收集对应watcher。\" class=\"headerlink\" title=\"1.不要将所有的数据都放在data中，data中的数据都会增加gettter和setter，会收集对应watcher。\"></a>1.不要将所有的数据都放在data中，data中的数据都会增加gettter和setter，会收集对应watcher。</h3><a id=\"more\"></a>\n<h3 id=\"2-vue在v-for时给每个元素绑定事件，需要事件代理。\"><a href=\"#2-vue在v-for时给每个元素绑定事件，需要事件代理。\" class=\"headerlink\" title=\"2.vue在v-for时给每个元素绑定事件，需要事件代理。\"></a>2.vue在v-for时给每个元素绑定事件，需要事件代理。</h3><h3 id=\"3-SPA页面采用keep-alive缓存组件。\"><a href=\"#3-SPA页面采用keep-alive缓存组件。\" class=\"headerlink\" title=\"3.SPA页面采用keep-alive缓存组件。\"></a>3.SPA页面采用keep-alive缓存组件。</h3><h3 id=\"4-拆分组件-提高复用性、增加代码的可维护性-减少不必要的渲染\"><a href=\"#4-拆分组件-提高复用性、增加代码的可维护性-减少不必要的渲染\" class=\"headerlink\" title=\"4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )\"></a>4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )</h3><h3 id=\"5-v-if-当值为false时内部指令不会执行-具有阻断功能，很多情况下使用v-if替代v-show。\"><a href=\"#5-v-if-当值为false时内部指令不会执行-具有阻断功能，很多情况下使用v-if替代v-show。\" class=\"headerlink\" title=\"5.v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show。\"></a>5.v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show。</h3><h3 id=\"6-key保证唯一性-默认vue会采用就地复用策略\"><a href=\"#6-key保证唯一性-默认vue会采用就地复用策略\" class=\"headerlink\" title=\"6.key保证唯一性 ( 默认vue会采用就地复用策略 )\"></a>6.key保证唯一性 ( 默认vue会采用就地复用策略 )</h3><h3 id=\"7-Object-freeze-冻结数据。\"><a href=\"#7-Object-freeze-冻结数据。\" class=\"headerlink\" title=\"7.Object.freeze 冻结数据。\"></a>7.Object.freeze 冻结数据。</h3><h3 id=\"8-合理使用路由懒加载、异步组件。\"><a href=\"#8-合理使用路由懒加载、异步组件。\" class=\"headerlink\" title=\"8.合理使用路由懒加载、异步组件。\"></a>8.合理使用路由懒加载、异步组件。</h3><h3 id=\"9-尽量采用runtime运行时版本\"><a href=\"#9-尽量采用runtime运行时版本\" class=\"headerlink\" title=\"9.尽量采用runtime运行时版本.\"></a>9.尽量采用runtime运行时版本.</h3><h3 id=\"10-数据持久化的问题（防抖、节流）\"><a href=\"#10-数据持久化的问题（防抖、节流）\" class=\"headerlink\" title=\"10.数据持久化的问题（防抖、节流）\"></a>10.数据持久化的问题（防抖、节流）</h3><h2 id=\"二-ue加载性能优化\"><a href=\"#二-ue加载性能优化\" class=\"headerlink\" title=\"二.ue加载性能优化\"></a>二.ue加载性能优化</h2><h3 id=\"1-第三方模块按需导入-babel-plugin-component\"><a href=\"#1-第三方模块按需导入-babel-plugin-component\" class=\"headerlink\" title=\"1.第三方模块按需导入 (babel-plugin-component)\"></a>1.第三方模块按需导入 (babel-plugin-component)</h3><h3 id=\"2-滚动到可视区域动态加载-https-tangbc-github-io-vue-virtual-scroll-list\"><a href=\"#2-滚动到可视区域动态加载-https-tangbc-github-io-vue-virtual-scroll-list\" class=\"headerlink\" title=\"2.滚动到可视区域动态加载 ( https://tangbc.github.io/vue-virtual-scroll-list )\"></a>2.滚动到可视区域动态加载 ( <a href=\"https://tangbc.github.io/vue-virtual-scroll-list\" target=\"_blank\" rel=\"noopener\">https://tangbc.github.io/vue-virtual-scroll-list</a> )</h3><h3 id=\"3-图片懒加载-https-github-com-hilongjw-vue-lazyload-git\"><a href=\"#3-图片懒加载-https-github-com-hilongjw-vue-lazyload-git\" class=\"headerlink\" title=\"3.图片懒加载 (https://github.com/hilongjw/vue-lazyload.git)\"></a>3.图片懒加载 (<a href=\"https://github.com/hilongjw/vue-lazyload.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hilongjw/vue-lazyload.git</a>)</h3><h2 id=\"三-用户体验\"><a href=\"#三-用户体验\" class=\"headerlink\" title=\"三.用户体验\"></a>三.用户体验</h2><h3 id=\"1-app-skeleton骨架屏\"><a href=\"#1-app-skeleton骨架屏\" class=\"headerlink\" title=\"1.app-skeleton骨架屏\"></a>1.app-skeleton骨架屏</h3><h3 id=\"2-app-shellapp壳\"><a href=\"#2-app-shellapp壳\" class=\"headerlink\" title=\"2.app-shellapp壳\"></a>2.app-shellapp壳</h3><h3 id=\"3-pwa\"><a href=\"#3-pwa\" class=\"headerlink\" title=\"3.pwa\"></a>3.pwa</h3><h2 id=\"四-SEO优化\"><a href=\"#四-SEO优化\" class=\"headerlink\" title=\"四.SEO优化\"></a>四.SEO优化</h2><h3 id=\"1-预渲染插件-prerender-spa-plugin\"><a href=\"#1-预渲染插件-prerender-spa-plugin\" class=\"headerlink\" title=\"1.预渲染插件 prerender-spa-plugin\"></a>1.预渲染插件 prerender-spa-plugin</h3><h3 id=\"2-服务端渲染ssr\"><a href=\"#2-服务端渲染ssr\" class=\"headerlink\" title=\"2.服务端渲染ssr\"></a>2.服务端渲染ssr</h3><h2 id=\"五-打包优化\"><a href=\"#五-打包优化\" class=\"headerlink\" title=\"五.打包优化\"></a>五.打包优化</h2><h3 id=\"1-使用cdn的方式加载第三方模块\"><a href=\"#1-使用cdn的方式加载第三方模块\" class=\"headerlink\" title=\"1.使用cdn的方式加载第三方模块\"></a>1.使用cdn的方式加载第三方模块</h3><h3 id=\"2-多线程打包-happypack\"><a href=\"#2-多线程打包-happypack\" class=\"headerlink\" title=\"2.多线程打包 happypack\"></a>2.多线程打包 happypack</h3><h3 id=\"3-splitChunks-抽离公共文件\"><a href=\"#3-splitChunks-抽离公共文件\" class=\"headerlink\" title=\"3.splitChunks 抽离公共文件\"></a>3.splitChunks 抽离公共文件</h3><h3 id=\"4-sourceMap生成\"><a href=\"#4-sourceMap生成\" class=\"headerlink\" title=\"4.sourceMap生成\"></a>4.sourceMap生成</h3><h2 id=\"六-缓存，压缩\"><a href=\"#六-缓存，压缩\" class=\"headerlink\" title=\"六.缓存，压缩\"></a>六.缓存，压缩</h2><h3 id=\"1-客户端缓存、服务端缓存\"><a href=\"#1-客户端缓存、服务端缓存\" class=\"headerlink\" title=\"1.客户端缓存、服务端缓存\"></a>1.客户端缓存、服务端缓存</h3><h3 id=\"2-服务端gzip压缩\"><a href=\"#2-服务端gzip压缩\" class=\"headerlink\" title=\"2.服务端gzip压缩\"></a>2.服务端gzip压缩</h3>","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"2020-4-14","date":"2020-04-13T16:00:00.000Z","path":"2020/04/14/2020.4.14/","text":"总结Vue面试题一.vue.js响应式数据的原理？1.核心点：object.defineProperty2. 默认Vue在初始化数据时，会给data中的属性使用Object.defineProperty重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。 二.computed，watch，method有什么区别？1.computed与watch比较，computed和watch都通过watcher方法进行监听，但computed具备缓存的功能，在页面刷新或切换组件时，会减少数据的重复调用，页面的渲染，节省性能。2.computed与method比较，computed比method的优势在于具备数据缓存功能，在提高性能方面computed比method好。三.ajax请求放在哪个生命周期中1.在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素。2.在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。一般情况下都放到mounted中,保证逻辑的统一性,因为生命周期是同步执行的，ajax是异步执行的。四.何时需要使用beforeDestrop1.当前页面使用了$on方法，需要在组件销毁前解绑。2.清除自己定义的定时器。3.解除事件绑定 scroll mousemove……五.为什么v-for和v-if不能连着用？v-for会比v-if优先级高一些，如果连着用的话会把v-if的每个元素都添加一下，会造成性能问题。不想把v-for放外层，想连着用就可以使用计算属性。六.用vnode描述一下DOM结构会将template =&gt; ast树 =&gt; codegen =&gt; render函数 =&gt; 内部调用的就是_c方法 =&gt; 虚拟dom总结：将template模板转化成虚拟dom。七.组件中的data为什么是一个函数？1.同一个组件被复用多次，会创建多个实例。2.这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。八.Vue中v-html会有哪些问题？1.可能会导致xss攻击。2.v-html会替换掉标签内子元素。","content":"<h2 id=\"总结Vue面试题\"><a href=\"#总结Vue面试题\" class=\"headerlink\" title=\"总结Vue面试题\"></a>总结Vue面试题</h2><h3 id=\"一-vue-js响应式数据的原理？\"><a href=\"#一-vue-js响应式数据的原理？\" class=\"headerlink\" title=\"一.vue.js响应式数据的原理？\"></a><strong>一.vue.js响应式数据的原理？</strong></h3><h4 id=\"1-核心点：object-defineProperty\"><a href=\"#1-核心点：object-defineProperty\" class=\"headerlink\" title=\"1.核心点：object.defineProperty\"></a>1.核心点：object.defineProperty</h4><h4 id=\"2-默认Vue在初始化数据时，会给data中的属性使用Object-defineProperty重新定义所有属性-当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher）-如果属性发生变化会通知相关依赖进行更新操作。\"><a href=\"#2-默认Vue在初始化数据时，会给data中的属性使用Object-defineProperty重新定义所有属性-当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher）-如果属性发生变化会通知相关依赖进行更新操作。\" class=\"headerlink\" title=\"2. 默认Vue在初始化数据时，会给data中的属性使用Object.defineProperty重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。\"></a>2. 默认Vue在初始化数据时，会给data中的属性使用Object.defineProperty重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。</h4><a id=\"more\"></a>\n<h3 id=\"二-computed，watch，method有什么区别？\"><a href=\"#二-computed，watch，method有什么区别？\" class=\"headerlink\" title=\"二.computed，watch，method有什么区别？\"></a><strong>二.computed，watch，method有什么区别？</strong></h3><h4 id=\"1-computed与watch比较，computed和watch都通过watcher方法进行监听，但computed具备缓存的功能，在页面刷新或切换组件时，会减少数据的重复调用，页面的渲染，节省性能。\"><a href=\"#1-computed与watch比较，computed和watch都通过watcher方法进行监听，但computed具备缓存的功能，在页面刷新或切换组件时，会减少数据的重复调用，页面的渲染，节省性能。\" class=\"headerlink\" title=\"1.computed与watch比较，computed和watch都通过watcher方法进行监听，但computed具备缓存的功能，在页面刷新或切换组件时，会减少数据的重复调用，页面的渲染，节省性能。\"></a>1.computed与watch比较，computed和watch都通过watcher方法进行监听，但computed具备缓存的功能，在页面刷新或切换组件时，会减少数据的重复调用，页面的渲染，节省性能。</h4><h4 id=\"2-computed与method比较，computed比method的优势在于具备数据缓存功能，在提高性能方面computed比method好。\"><a href=\"#2-computed与method比较，computed比method的优势在于具备数据缓存功能，在提高性能方面computed比method好。\" class=\"headerlink\" title=\"2.computed与method比较，computed比method的优势在于具备数据缓存功能，在提高性能方面computed比method好。\"></a>2.computed与method比较，computed比method的优势在于具备数据缓存功能，在提高性能方面computed比method好。</h4><h3 id=\"三-ajax请求放在哪个生命周期中\"><a href=\"#三-ajax请求放在哪个生命周期中\" class=\"headerlink\" title=\"三.ajax请求放在哪个生命周期中\"></a><em>三.ajax请求放在哪个生命周期中</em></h3><h4 id=\"1-在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素。\"><a href=\"#1-在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素。\" class=\"headerlink\" title=\"1.在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素。\"></a>1.在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素。</h4><h4 id=\"2-在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。\"><a href=\"#2-在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。\" class=\"headerlink\" title=\"2.在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。\"></a>2.在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。</h4><h4 id=\"一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的，ajax是异步执行的。\"><a href=\"#一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的，ajax是异步执行的。\" class=\"headerlink\" title=\"一般情况下都放到mounted中,保证逻辑的统一性,因为生命周期是同步执行的，ajax是异步执行的。\"></a>一般情况下都放到mounted中,保证逻辑的统一性,因为生命周期是同步执行的，ajax是异步执行的。</h4><h3 id=\"四-何时需要使用beforeDestrop\"><a href=\"#四-何时需要使用beforeDestrop\" class=\"headerlink\" title=\"四.何时需要使用beforeDestrop\"></a><em>四.何时需要使用beforeDestrop</em></h3><h4 id=\"1-当前页面使用了-on方法，需要在组件销毁前解绑。\"><a href=\"#1-当前页面使用了-on方法，需要在组件销毁前解绑。\" class=\"headerlink\" title=\"1.当前页面使用了$on方法，需要在组件销毁前解绑。\"></a>1.当前页面使用了$on方法，需要在组件销毁前解绑。</h4><h4 id=\"2-清除自己定义的定时器。\"><a href=\"#2-清除自己定义的定时器。\" class=\"headerlink\" title=\"2.清除自己定义的定时器。\"></a>2.清除自己定义的定时器。</h4><h4 id=\"3-解除事件绑定-scroll-mousemove……\"><a href=\"#3-解除事件绑定-scroll-mousemove……\" class=\"headerlink\" title=\"3.解除事件绑定 scroll  mousemove……\"></a>3.解除事件绑定 scroll  mousemove……</h4><h3 id=\"五-为什么v-for和v-if不能连着用？\"><a href=\"#五-为什么v-for和v-if不能连着用？\" class=\"headerlink\" title=\"五.为什么v-for和v-if不能连着用？\"></a><em>五.为什么v-for和v-if不能连着用？</em></h3><h4 id=\"v-for会比v-if优先级高一些，如果连着用的话会把v-if的每个元素都添加一下，会造成性能问题。\"><a href=\"#v-for会比v-if优先级高一些，如果连着用的话会把v-if的每个元素都添加一下，会造成性能问题。\" class=\"headerlink\" title=\"v-for会比v-if优先级高一些，如果连着用的话会把v-if的每个元素都添加一下，会造成性能问题。\"></a>v-for会比v-if优先级高一些，如果连着用的话会把v-if的每个元素都添加一下，会造成性能问题。</h4><h4 id=\"不想把v-for放外层，想连着用就可以使用计算属性。\"><a href=\"#不想把v-for放外层，想连着用就可以使用计算属性。\" class=\"headerlink\" title=\"不想把v-for放外层，想连着用就可以使用计算属性。\"></a>不想把v-for放外层，想连着用就可以使用计算属性。</h4><h3 id=\"六-用vnode描述一下DOM结构\"><a href=\"#六-用vnode描述一下DOM结构\" class=\"headerlink\" title=\"六.用vnode描述一下DOM结构\"></a><em>六.用vnode描述一下DOM结构</em></h3><h4 id=\"会将template-gt-ast树-gt-codegen-gt-render函数-gt-内部调用的就是-c方法-gt-虚拟dom\"><a href=\"#会将template-gt-ast树-gt-codegen-gt-render函数-gt-内部调用的就是-c方法-gt-虚拟dom\" class=\"headerlink\" title=\"会将template =&gt; ast树 =&gt; codegen =&gt; render函数 =&gt; 内部调用的就是_c方法 =&gt; 虚拟dom\"></a>会将template =&gt; ast树 =&gt; codegen =&gt; render函数 =&gt; 内部调用的就是_c方法 =&gt; 虚拟dom</h4><h4 id=\"总结：将template模板转化成虚拟dom。\"><a href=\"#总结：将template模板转化成虚拟dom。\" class=\"headerlink\" title=\"总结：将template模板转化成虚拟dom。\"></a>总结：将template模板转化成虚拟dom。</h4><h3 id=\"七-组件中的data为什么是一个函数？\"><a href=\"#七-组件中的data为什么是一个函数？\" class=\"headerlink\" title=\"七.组件中的data为什么是一个函数？\"></a><em>七.组件中的data为什么是一个函数？</em></h3><h4 id=\"1-同一个组件被复用多次，会创建多个实例。\"><a href=\"#1-同一个组件被复用多次，会创建多个实例。\" class=\"headerlink\" title=\"1.同一个组件被复用多次，会创建多个实例。\"></a>1.同一个组件被复用多次，会创建多个实例。</h4><h4 id=\"2-这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。\"><a href=\"#2-这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。\" class=\"headerlink\" title=\"2.这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。\"></a>2.这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。</h4><h3 id=\"八-Vue中v-html会有哪些问题？\"><a href=\"#八-Vue中v-html会有哪些问题？\" class=\"headerlink\" title=\"八.Vue中v-html会有哪些问题？\"></a><em>八.Vue中v-html会有哪些问题？</em></h3><h4 id=\"1-可能会导致xss攻击。\"><a href=\"#1-可能会导致xss攻击。\" class=\"headerlink\" title=\"1.可能会导致xss攻击。\"></a>1.可能会导致xss攻击。</h4><h4 id=\"2-v-html会替换掉标签内子元素。\"><a href=\"#2-v-html会替换掉标签内子元素。\" class=\"headerlink\" title=\"2.v-html会替换掉标签内子元素。\"></a>2.v-html会替换掉标签内子元素。</h4><!-- ## Quick Start\n\n### Create a new post\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a> –&gt;</p>\n-->","tags":[{"name":"自我总结","slug":"自我总结","permalink":"http://yoursite.com/tags/自我总结/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vue面试题","slug":"Vue面试题","permalink":"http://yoursite.com/tags/Vue面试题/"}]}]